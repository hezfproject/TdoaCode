/**************************************************************************************************
  Filename:       hal_lcd.c
  Revised:        $Date: 2011/04/06 23:19:06 $
  Revision:       $Revision: 1.1 $

  Description:    This file contains the interface to the HAL LCD Service.


  Copyright 2007-2010 Texas Instruments Incorporated. All rights reserved.

  IMPORTANT: Your use of this Software is limited to those specific rights
  granted under the terms of a software license agreement between the user
  who downloaded the software, his/her employer (which must be your employer)
  and Texas Instruments Incorporated (the "License").  You may not use this
  Software unless you agree to abide by the terms of the License. The License
  limits your use, and you acknowledge, that the Software may not be modified,
  copied or distributed unless embedded on a Texas Instruments microcontroller
  or used solely and exclusively in conjunction with a Texas Instruments radio
  frequency transceiver, which is integrated into your product.  Other than for
  the foregoing purpose, you may not use, reproduce, copy, prepare derivative
  works of, modify, distribute, perform, display or sell this Software and/or
  its documentation for any purpose.

  YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
  PROVIDED AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
  INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
  NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
  TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
  NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
  LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
  OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
  OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.

  Should you have any questions regarding your right to use this Software,
  contact Texas Instruments Incorporated at www.TI.com.
**************************************************************************************************/

/**************************************************************************************************
 *                                           INCLUDES
 **************************************************************************************************/
#include "hal_mcu.h"
#include "hal_lcd.h"
//#include "hal_timer.h"
#include "ssd1306.h"
//#include <string.h>


#if defined (ZTOOL_P1) || defined (ZTOOL_P2)
  #include "DebugTrace.h"
#endif

/**************************************************************************************************
 *                                           MACROS
 **************************************************************************************************/

/*
  LCD pins

  //old  control                                        new
  P0.0 - LCD_MODE                                 P0.0
  P1.1 - LCD_FLASH_RESET                     P0.1
  P1.2 - LCD_CS                                      P0.4

  //spi
  P1.5 - CLK                                            P0.5
  P1.6 - MOSI                                          P0.3
  P1.7 - MISO
*/

/* LCD Control lines */
//#define HAL_LCD_MODE_PORT 0
//#define HAL_LCD_MODE_PIN  0

#define HAL_LCD_RESET_PORT    0//;1
#define HAL_LCD_RESET_PIN  		1

#define HAL_LCD_CS_PORT      0//;1
#define HAL_LCD_CS_PIN        4//;2

/* ************font lib  ************************************ */
#define HAL_LCD_MODE_PORT 2
#define HAL_LCD_MODE_PIN  0

//#define HAL_LCD_RESET_PORT    0//;1
//#define HAL_LCD_RESET_PIN  1

#define HAL_FONT_CS_PORT      HAL_LCD_CS_PORT
#define HAL_FONT_CS_PIN       HAL_LCD_CS_PIN

/* LCD/FONT  SPI lines */
#define HAL_LCD_CLK_PORT       0//;1
#define HAL_LCD_CLK_PIN        5 //;5

#define HAL_LCD_MOSI_PORT     0//; 1
#define HAL_LCD_MOSI_PIN       3 //;  6

#define HAL_LCD_MISO_PORT  0//;1
#define HAL_LCD_MISO_PIN     2 //;7

/* SPI settings */
#define HAL_SPI_CLOCK_POL_LO       0x00
#define HAL_SPI_CLOCK_PHA_0        0x00
#define HAL_SPI_TRANSFER_MSB_FIRST 0x20

#define   LCD_MAX_LINE_LENGTH  	  127
#define   LCD_MAX_LINE_HIGH       63
#define   LCD_MAX_PAGE_COUNT      5

/* Defines for HW LCD */
//#define   LCD_SET_MEM_MODE_REG       (0x20)
//#define   LCD_SET_MODE_PAGE          (0x02)
//#define   LCD_SET_MODE_HORIZONTAL    (0x00)
//#define   LCD_SET_MODE_VERTICAL      (0x01)

//#define   LCD_SET_COLUMN_REG         (0x21)

//#define   LCD_SET_PAGE_ADDR_REG      (0x22)
//#define   LCD_SET_PAGE_ADDR_BESE     (0xB0)


#define HAL_IO_SET(port, pin, val)        HAL_IO_SET_PREP(port, pin, val)
#define HAL_IO_SET_PREP(port, pin, val)   st( P##port##_##pin## = val; )

#define HAL_CONFIG_IO_OUTPUT(port, pin, val)      HAL_CONFIG_IO_OUTPUT_PREP(port, pin, val)
#define HAL_CONFIG_IO_OUTPUT_PREP(port, pin, val) st( P##port##SEL &= ~BV(pin); \
                                                      P##port##_##pin## = val; \
                                                      P##port##DIR |= BV(pin); )

#define HAL_CONFIG_IO_PERIPHERAL(port, pin)      HAL_CONFIG_IO_PERIPHERAL_PREP(port, pin)
#define HAL_CONFIG_IO_PERIPHERAL_PREP(port, pin) st( P##port##SEL |= BV(pin); )

#define HAL_CONFIG_IO_INPUT(port, pin) st( P##port##SEL &= ~BV(pin); \
                                           P##port##DIR &= ~(BV(pin)); )

/* LCD SPI interface control */
#define LCD_SPI_BEGIN()     HAL_IO_SET(HAL_LCD_CS_PORT,  HAL_LCD_CS_PIN,  0); /* chip select */
#define LCD_SPI_END()                                                         \
{                                                                             \
  asm("NOP");                                                                 \
  asm("NOP");                                                                 \
  asm("NOP");                                                                 \
  asm("NOP");                                                                 \
  HAL_IO_SET(HAL_LCD_CS_PORT,  HAL_LCD_CS_PIN,  1); /* chip select */         \
}
/* clear the received and transmit byte status, write tx data to buffer, wait till transmit done */
#define LCD_SPI_TX(x)                   { U0CSR &= ~(BV(2) | BV(1)); U0DBUF = x; while( !(U0CSR & BV(1)) ); }
#define LCD_SPI_WAIT_RXRDY()            { while(!(U0CSR & BV(1))); }


/* Control macros */
#define LCD_DO_WRITE()       HAL_IO_SET(HAL_LCD_MODE_PORT,  HAL_LCD_MODE_PIN,  1);    //P2_0 =1
#define LCD_DO_CONTROL()     HAL_IO_SET(HAL_LCD_MODE_PORT,  HAL_LCD_MODE_PIN,  0);    //P2_0 =0

#define LCD_ACTIVATE_RESET()  HAL_IO_SET(HAL_LCD_RESET_PORT, HAL_LCD_RESET_PIN, 0);
#define LCD_RELEASE_RESET()   HAL_IO_SET(HAL_LCD_RESET_PORT, HAL_LCD_RESET_PIN, 1);

/* FONT SPI interface control */
#define FONT_SPI_BEGIN()     HAL_IO_SET(HAL_FONT_CS_PORT,  HAL_FONT_CS_PIN,  1); /* chip select */
#define FONT_SPI_END()                                                         \
{                                                                             \
  asm("NOP");                                                                 \
  asm("NOP");                                                                 \
  asm("NOP");                                                                 \
  asm("NOP");                                                                 \
  HAL_IO_SET(HAL_FONT_CS_PORT,  HAL_FONT_CS_PIN,  0); /* chip select */         \
}
/* clear the received and transmit byte status, write tx data to buffer, wait till transmit done */
#define FONT_SPI_TX_RX(input,output)                   { U0CSR &= ~(BV(2) | BV(1)); U0DBUF = input; while( !(U0CSR & BV(1)) );output=U0DBUF;}
#define FONT_SPI_WAIT_RXRDY()            { while(!(U0CSR & BV(1))); }


#define  LCD_SUCCESS      0
#define  LCD_INVALID_PARAMETER     1
#define  LCD_GET_FONT_FAULT           2

#define led_start_offset  32
const UINT8 CODE DisplayNum24X12[14][36]={
        
        {0x00,0x00,0x80,0xC0,0x60,0x20,0x20,0x60,0xC0,0x80,0x00,0x00,0x00,0xFE,
        0xFF,0x01,0x00,0x00,0x00,0x00,0x01,0xFF,0xFE,0x00,0x00,0x01,0x07,0x0E,
        0x18,0x10,0x10,0x18,0x0E,0x07,0x01,0x00},/*"0",0*/
        
        {0x00,0x00,0x80,0x80,0x80,0xC0,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x10,
        0x10,0x1F,0x1F,0x10,0x10,0x10,0x00,0x00},/*"1",1*/
        
        {0x00,0x80,0x40,0x20,0x20,0x20,0x20,0x60,0xC0,0x80,0x00,0x00,0x00,0x03,
        0x03,0x00,0x80,0x40,0x20,0x38,0x1F,0x07,0x00,0x00,0x00,0x1C,0x1A,0x19,
        0x18,0x18,0x18,0x18,0x18,0x1F,0x00,0x00},/*"2",2*/
        
        {0x00,0x80,0xC0,0x20,0x20,0x20,0x60,0xC0,0x80,0x00,0x00,0x00,0x00,0x03,
        0x03,0x00,0x10,0x10,0x18,0x2F,0xE7,0x80,0x00,0x00,0x00,0x07,0x0F,0x10,
        0x10,0x10,0x10,0x18,0x0F,0x07,0x00,0x00},/*"3",3*/
        
        {0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xE0,0xF0,0x00,0x00,0x00,0x00,0xC0,
        0xB0,0x88,0x86,0x81,0x80,0xFF,0xFF,0x80,0x80,0x00,0x00,0x00,0x00,0x00,
        0x00,0x10,0x10,0x1F,0x1F,0x10,0x10,0x00},/*"4",4*/
        
        {0x00,0x00,0xE0,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x00,0x00,0x00,0x00,
        0x3F,0x10,0x08,0x08,0x08,0x18,0xF0,0xE0,0x00,0x00,0x00,0x07,0x0B,0x10,
        0x10,0x10,0x10,0x1C,0x0F,0x03,0x00,0x00},/*"5",5*/
        
        {0x00,0x00,0x80,0xC0,0x40,0x20,0x20,0x20,0xE0,0xC0,0x00,0x00,0x00,0xFC,
        0xFF,0x21,0x10,0x08,0x08,0x08,0x18,0xF0,0xE0,0x00,0x00,0x01,0x07,0x0C,
        0x18,0x10,0x10,0x10,0x08,0x0F,0x03,0x00},/*"6",6*/
        
        {0x00,0x00,0xC0,0xE0,0x60,0x60,0x60,0x60,0x60,0xE0,0x60,0x00,0x00,0x00,
        0x03,0x00,0x00,0x00,0xE0,0x18,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x1F,0x1F,0x00,0x00,0x00,0x00,0x00},/*"7",7*/
        
        {0x00,0x80,0xC0,0x60,0x20,0x20,0x20,0x20,0x60,0xC0,0x80,0x00,0x00,0x87,
        0xEF,0x2C,0x18,0x18,0x30,0x30,0x68,0xCF,0x83,0x00,0x00,0x07,0x0F,0x08,
        0x10,0x10,0x10,0x10,0x18,0x0F,0x07,0x00},/*"8",8*/
        
        {0x00,0x00,0xC0,0xC0,0x20,0x20,0x20,0x20,0xC0,0x80,0x00,0x00,0x00,0x1F,
        0x3F,0x60,0x40,0x40,0x40,0x20,0x10,0xFF,0xFE,0x00,0x00,0x00,0x0C,0x1C,
        0x10,0x10,0x10,0x08,0x0F,0x03,0x00,0x00},/*"9",9*/
        
        {0x00,0x00,0x20,0x20,0x20,0xE0,0xE0,0x20,0x20,0x20,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x10,
        0x10,0x1F,0x1F,0x10,0x10,0x10,0x00,0x00},/*"I",0*/
        
        {0x20,0xE0,0xE0,0x20,0x20,0x20,0x20,0x40,0xC0,0x80,0x00,0x00,0x00,0xFF,
        0xFF,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xFE,0x00,0x10,0x1F,0x1F,0x10,
        0x10,0x10,0x18,0x08,0x0E,0x07,0x01,0x00},/*"D",1*/
        
        {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x0E,0x0E,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x1C,0x1C,0x1C,0x00,0x00,0x00,0x00},/*":",2*/
        
        {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*" ",2*/
};


const UINT8 CODE DisplayNum32X16[10][64] = { //40X24
	
	{0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0x40,0x40,0x40,
	0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0xFE,
	0x0F,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x07,0xFE,
	0xF0,0x00,0x00,0x00,0x1F,0xFF,0xE0,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0xC0,0xFF,0x1F,0x00,0x00,0x00,
	0x00,0x00,0x01,0x03,0x06,0x04,0x04,0x04,0x06,0x03,
	0x01,0x00,0x00,0x00},/*"0",0*/
	
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
	0x01,0x01,0x01,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
	0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x04,0x04,0x04,0x06,0x07,0x07,0x06,0x04,0x04,
	0x04,0x00,0x00,0x00},/*"1",1*/
	
	{0x00,0x00,0x00,0x00,0x80,0x40,0x40,0x40,0x40,0x40,
	0xC0,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x1E,0x19,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC1,0x7F,0x3E,
	0x00,0x00,0x00,0x00,0x00,0x80,0x40,0x20,0x10,0x08,
	0x04,0x02,0x01,0x00,0x00,0xE0,0x00,0x00,0x00,0x00,
	0x07,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
	0x07,0x01,0x00,0x00},/*"2",2*/
	
	{0x00,0x00,0x00,0x80,0x80,0x40,0x40,0x40,0x40,0xC0,
	0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0x0F,
	0x00,0x00,0x80,0x80,0x80,0xC0,0x61,0x3F,0x1E,0x00,
	0x00,0x00,0x00,0x00,0xE0,0xE0,0x00,0x00,0x00,0x00,
	0x00,0x01,0x01,0x03,0xFE,0x78,0x00,0x00,0x00,0x00,
	0x01,0x03,0x02,0x04,0x04,0x04,0x04,0x04,0x02,0x03,
	0x01,0x00,0x00,0x00},/*"3",3*/
	
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,
	0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x80,0x60,0x30,0x0C,0x02,0xFF,0xFF,0xFF,0x00,0x00,
	0x00,0x00,0x00,0x10,0x1C,0x12,0x11,0x10,0x10,0x10,
	0x10,0xFF,0xFF,0xFF,0x10,0x10,0x10,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x08,0x08,0x08,0x0F,0x0F,0x0F,
	0x08,0x08,0x08,0x00},/*"4",4*/
	
	{0x00,0x00,0x00,0x00,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,
	0xC0,0xC0,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0xF8,
	0x87,0x40,0x20,0x20,0x20,0x20,0x60,0xC0,0x80,0x00,
	0x00,0x00,0x00,0x00,0xE0,0x61,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x80,0xFF,0x7E,0x00,0x00,0x00,0x00,
	0x01,0x02,0x04,0x04,0x04,0x04,0x04,0x04,0x02,0x03,
	0x01,0x00,0x00,0x00},/*"5",5*/
	
	{0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0x40,0x40,
	0x40,0x40,0x80,0x00,0x00,0x00,0x00,0x00,0xE0,0xFC,
	0x0E,0x81,0x80,0x40,0x40,0x40,0x40,0xC0,0x83,0x03,
	0x00,0x00,0x00,0x00,0x3F,0xFF,0xC3,0x01,0x00,0x00,
	0x00,0x00,0x00,0x00,0x01,0xFF,0x7E,0x00,0x00,0x00,
	0x00,0x00,0x01,0x03,0x06,0x04,0x04,0x04,0x04,0x02,
	0x03,0x01,0x00,0x00},/*"6",6*/
	
	{0x00,0x00,0x00,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,
	0xC0,0xC0,0xC0,0xC0,0x00,0x00,0x00,0x00,0x0F,0x03,
	0x01,0x00,0x00,0x00,0x80,0x60,0x18,0x06,0x01,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0xFC,
	0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x07,0x07,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00},/*"7",7*/
	
	{0x00,0x00,0x00,0x00,0x80,0xC0,0x40,0x40,0x40,0x40,
	0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x1E,0x3F,
	0x71,0xE0,0xC0,0x80,0x80,0x80,0x80,0x61,0x3F,0x1E,
	0x00,0x00,0x00,0xF8,0xFC,0x06,0x03,0x01,0x00,0x01,
	0x01,0x03,0x07,0x0E,0xFC,0xF8,0x00,0x00,0x00,0x00,
	0x01,0x03,0x02,0x04,0x04,0x04,0x04,0x04,0x02,0x03,
	0x01,0x00,0x00,0x00},/*"8",8*/
	
	{0x00,0x00,0x00,0x80,0x80,0x40,0x40,0x40,0x40,0x40,
	0x80,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0xFF,0x03,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x83,0xFE,0xF8,
	0x00,0x00,0x00,0x00,0x81,0x83,0x06,0x04,0x04,0x04,
	0x04,0x02,0x83,0xF1,0x7F,0x0F,0x00,0x00,0x00,0x00,
	0x03,0x03,0x04,0x04,0x04,0x04,0x06,0x03,0x01,0x00,
	0x00,0x00,0x00,0x00},/*"9",9*/

};

/*--  文字:  日期  --*///32X24
const UINT8 CODE DisplayDate24X16[2][48]={
{0x00,0x00,0x00,0x00,0xFC,0xFC,0x08,0x08,0x08,0x08,0x08,0xF8,0xF8,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x21,0x21,0x21,0x21,0x21,0xFF,0xFF,0x00,0x00,0x00,
0x00,0x40,0x60,0x3C,0x1F,0x03,0x00,0x00,0x00,0x20,0x60,0x7F,0x7F,0x00,0x00,0x00},/*"月",0*/

{0x00,0x00,0x00,0xFC,0xFC,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0xF8,0xF8,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0xFF,0xFF,0x00,0x00,
0x00,0x00,0x00,0x7F,0x7F,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x3F,0x3F,0x00,0x00},/*"日",1*/

};
const UINT8 CODE DisplayDate10X12[2][20]={

{0x00,0x00,0xFE,0x52,0x52,0x52,0x52,0xFE,0x00,0x00,0x04,0x02,0x01,0x00,0x00,0x00,0x04,0x03,0x00,0x00},/*"月",0*/

{0x00,0x00,0xFE,0x22,0x22,0x22,0x22,0xFE,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x02,0x02,0x07,0x00,0x00},/*"日",1*/

};


/*--  文字:  sos  --*/

const UINT8 CODE DisplaySOS24X16[3][48]={//40X16


{0x00,0x00,0x80,0xC0,0xC0,0x60,0x20,0x20,0x20,0x20,0x20,0x60,0xC0,0xE0,0xE0,0x00,0x00,0x00,0x07,0x0F,0x0F,0x0C,0x18,0x18,0x18,0x30,0x30,0x70,0xE0,0xE1,0xC1,0x80,
0x00,0x00,0x03,0x1F,0x1E,0x08,0x18,0x10,0x10,0x10,0x10,0x18,0x18,0x0F,0x0F,0x07},/*"S",0*/

{0x00,0x00,0x00,0x80,0xC0,0xE0,0x60,0x20,0x20,0x20,0x60,0x60,0xC0,0x80,0x00,0x00,0x00,0xFC,0xFF,0xFF,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xFF,0xFC,
0x00,0x00,0x03,0x07,0x0E,0x1C,0x18,0x10,0x10,0x10,0x18,0x18,0x0E,0x07,0x03,0x00},/*"O",1*/

{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*" ",2*/

};

/*--  文字:  :  --*///old 40X24
const UINT8 CODE Char32X16_COLON[64]={ 
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xE0,
0xE0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x81,
0x81,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x07,
0x07,0x03,0x00,0x00,0x00,0x00,0x00,0x00

};/*":",0*/
const UINT8 CODE Char24X12_COLON[36]={ 
0x00,0x00,0x00,0x00,0xC0,0xC0,0xC0,0xC0,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x81,0x81,0x81,0x81,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x03,0x03,0x03,0x03,
0x00,0x00,0x00,0x00
	
};/*"：",0*/

const UINT8 CODE DisplayTumble24X24[2][72]={

{0x00,0x00,0x00,0xF0,0x10,0x10,0x10,0x10,0xF8,0x10,0x00,0x80,0xF8,0x90,0x80,0xFC,0xFC,0x80,0x80,0x80,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0xE7,0x02,0x02,0xFE,0x42,
0x27,0x08,0x14,0x13,0x10,0x10,0x10,0xFF,0x77,0x90,0x10,0x10,0x10,0x18,0x00,0x00,0x00,0x10,0x30,0x1F,0x10,0x08,0x0F,0x08,0x48,0x44,0x20,0x10,0x18,0x0C,0x03,0x00,
0x00,0x03,0x0E,0x18,0x30,0x60,0x20,0x00},/*"跌",0*/

{0x00,0x00,0x00,0x00,0xE0,0x3C,0x0C,0x10,0x10,0x90,0x70,0x30,0x10,0x10,0x18,0x10,0x00,0xC0,0x00,0x00,0xFC,0xFC,0x00,0x00,0x00,0x08,0x04,0x03,0xFF,0x00,0x00,0x80,
0x86,0x85,0x8C,0xF4,0x94,0x85,0xC7,0x84,0x00,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x00,0x00,0x30,0x30,0x10,0x10,0x0F,0x08,0x08,0x08,0x00,
0x00,0x23,0x20,0x60,0x7F,0x3F,0x00,0x00},/*"倒",1*/
};

const UINT8 CODE Char24X12_GANT[36]={

0x00,0x00,0x00,0x00,0x00,0xF0,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0x0E,0x00,
0x00,0x00,0x00,0x00

};/*"！",0*/


/*--  文字:  :  --*///40X24
const UINT8 CODE Char32X16_OFFCOLON[64]={
//0x00,0x00,0x00,0x00,0x00,
//0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00

/*":",0*/
};

const UINT8 CODE DisplayWeather24X16[5][48]={  //40X16
{0x00,0x00,0x00,0x10,0x10,0x10,0x10,0xF0,0x10,0x10,0x10,0x08,0x08,0x00,0x00,0x00,0x00,0x00,0x08,0x08,0x08,0x08,0xC8,0x3F,0x38,0xC8,0x08,0x08,0x04,0x06,0x00,0x00,
0x00,0x40,0x20,0x10,0x08,0x06,0x01,0x00,0x00,0x01,0x02,0x0C,0x18,0x70,0x20,0x00},/*"天",0*/

{0x00,0x00,0x00,0xE0,0x3C,0x24,0x20,0x20,0x20,0x20,0x20,0xA0,0x30,0x30,0x00,0x00,0x00,0x06,0x01,0x08,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0xFD,0x01,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0x30,0x60,0x7C,0x00},/*"气",1*/

{0x00,0xF8,0x10,0x10,0xF0,0x10,0x10,0x90,0x90,0x90,0xFC,0x90,0x90,0x98,0x10,0x00,0x00,0xFF,0x04,0x04,0xFF,0x00,0x04,0xF4,0x94,0x94,0x97,0x94,0xFC,0x14,0x06,0x00,
0x00,0x0F,0x02,0x02,0x0F,0x00,0x00,0x7F,0x02,0x02,0x22,0x42,0x7F,0x00,0x00,0x00},/*"晴",2*/

{0x00,0x00,0xF8,0x08,0x88,0x78,0x08,0x00,0xFC,0x08,0x08,0x08,0x08,0xFC,0x00,0x00,0x00,0x00,0xFF,0x00,0x03,0x8C,0xF0,0x00,0xFF,0x21,0x21,0x21,0x21,0xFF,0x00,0x00,
0x00,0x00,0x7F,0x01,0x01,0x61,0x10,0x0E,0x01,0x00,0x00,0x20,0x60,0x3F,0x00,0x00},/*"阴",3*/

{0x00,0x00,0x90,0x10,0x10,0x10,0x10,0xF0,0x10,0x10,0x10,0x10,0x90,0x8C,0x00,0x00,0x00,0x00,0xFF,0x01,0x85,0x0D,0x01,0xFF,0x01,0x85,0x0D,0x01,0xFF,0x00,0x00,0x00,
0x00,0x00,0x7F,0x00,0x00,0x03,0x00,0x3F,0x00,0x00,0x13,0x20,0x7F,0x00,0x00,0x00},/*"雨",4*/

};
/*--  文字:  星期--*/
const UINT8 CODE DisplayWeek16X8[9][32]={//12*12
	
{0x00,0xBE,0x2A,0x2A,0x2A,0xEA,0x2A,0x2A,0x2A,0x3E,0x00,0x00,0x12,0x11,0x15,0x15,0x15,0x1F,0x15,0x15,0x15,0x11,0x10,0x00},/*"星",0*/

{0x08,0xFE,0xA8,0xA8,0xFE,0x08,0x00,0xFC,0x24,0x24,0xFC,0x00,0x12,0x0B,0x02,0x02,0x0B,0x12,0x10,0x0F,0x01,0x11,0x1F,0x00},/*"期",1*/

{0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"一",2*/

{0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00,0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00},/*"二",3*/

{0x00,0x02,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x02,0x00,0x00,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x00},/*"三",4*/

{0x00,0xFE,0x02,0x82,0x7E,0x02,0x02,0x7E,0x82,0x82,0xFE,0x00,0x00,0x0F,0x05,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x0F,0x00},/*"四",5*/

{0x02,0x22,0x22,0xE2,0x3E,0x22,0x22,0x22,0xE2,0x02,0x00,0x00,0x08,0x08,0x0E,0x09,0x08,0x08,0x08,0x08,0x0F,0x08,0x08,0x00},/*"五",6*/

{0x10,0x10,0x10,0xD0,0x11,0x16,0x10,0x50,0x90,0x10,0x10,0x00,0x08,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x0C,0x00},/*"六",7*/

//{0x20,0x20,0x20,0x20,0xFF,0x10,0x10,0x10,0x10,0x10,0x10,0x00,0x00,0x00,0x00,0x00,0x07,0x08,0x08,0x08,0x08,0x08,0x0E,0x00},/*"七",8*/

{0x00,0x00,0xFE,0x24,0x24,0x24,0x24,0x24,0xFE,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x02,0x02,0x02,0x07,0x00,0x00,0x00},/*"日",8*/

};

const UINT8 CODE DisplayBandConnect[2][32]={  //12*12
{0x00,0x60,0x60,0x60,0x60,0x60,0xF0,0x08,0x08,0xF0,0x60,0x60,0x60,0x60,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"未命名文件",0*/

{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},

};
const UINT8 CODE DisplayNoSMS24X24[4][72]={
{0x00,0x80,0x00,0x00,0x08,0x18,0x30,0x80,0x40,0x00,0x00,0xF8,0x38,0x08,0x08,0x08,0x08,0xFC,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x07,0x06,0xE0,0x1C,0x13,
0x08,0x14,0x16,0x31,0xD0,0x10,0x10,0x10,0x90,0xF3,0x3A,0x12,0x02,0x02,0x00,0x00,0x00,0x00,0x01,0x31,0x3F,0x01,0x00,0x40,0x40,0x40,0x20,0x20,0x10,0x0B,0x0C,0x0E,
0x1B,0x30,0x30,0x60,0x60,0x20,0x20,0x00},/*"没",0*/

{0x00,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0xA0,0xE0,0x3C,0x2C,0x24,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x30,0x30,0x20,0x00,0x00,0x80,0x40,0x20,0x30,0x18,0x0C,0xFE,
0x23,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0xFF,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x02,0x02,0x02,0x02,0x02,0x02,0x22,0x22,
0x62,0x7F,0x00,0x00,0x00,0x00,0x00,0x00},/*"有",1*/

{0x00,0x00,0x00,0xC0,0x7C,0x4C,0xC4,0x40,0x40,0x40,0x00,0x10,0x90,0x10,0x10,0x10,0x10,0x10,0x10,0x88,0x0C,0x08,0x00,0x00,0x00,0x00,0x13,0x10,0x10,0xD0,0xFF,0x10,
0x10,0x18,0x10,0x00,0x7F,0x21,0x21,0x21,0x21,0x21,0xA1,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x30,0x1C,0x07,0x00,0x01,0x03,0x2E,0x20,0x20,0x21,0x3E,0x20,0x20,
0x30,0x2C,0x23,0x21,0x20,0x30,0x00,0x00},/*"短",2*/

{0x00,0x00,0x00,0x00,0x80,0xE0,0x3C,0x0C,0x20,0x20,0x20,0x20,0x20,0x24,0x3C,0x38,0x20,0x20,0x20,0x20,0x30,0x20,0x00,0x00,0x00,0x30,0x08,0x06,0x03,0xFF,0x00,0x00,
0x00,0x10,0x92,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x99,0x90,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x00,0x00,0x00,0x00,0x7F,0x11,0x11,0x11,0x11,0x11,
0x11,0x11,0x11,0x7F,0x00,0x00,0x00,0x00},/*"信",3*/

};

const UINT8 CODE Char20X16_Battery[5][40]={  //20*16

{0x00,0x00,0xFC,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0xFC,0xF0,0x00,0x00,0x00,0x00,0x00,0x03,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
0x02,0x02,0x02,0x03,0x00,0x00,0x00,0x00},/*"空电池",0*/

{0x00,0x00,0xFC,0xFC,0xFC,0xFC,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0xFC,0xF0,0x00,0x00,0x00,0x00,0x00,0x03,0x03,0x03,0x03,0x02,0x02,0x02,0x02,0x02,0x02,
0x02,0x02,0x02,0x03,0x00,0x00,0x00,0x00},/*\一格点,0*/

	
{0x00,0x00,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0x04,0x04,0x04,0x04,0x04,0x04,0xFC,0xF0,0x00,0x00,0x00,0x00,0x00,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x02,0x02,0x02,
0x02,0x02,0x02,0x03,0x00,0x00,0x00,0x00},/*"两格点",0*/

{0x00,0x00,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0x04,0x04,0x04,0xFC,0xF0,0x00,0x00,0x00,0x00,0x00,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
0x02,0x02,0x02,0x03,0x00,0x00,0x00,0x00},/*"三格电",0*/

{0x00,0x00,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xF0,0x00,0x00,0x00,0x00,0x00,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
0x03,0x03,0x03,0x03,0x00,0x00,0x00,0x00},/*四格满电,0*/


};

const UINT8 CODE Char96X40_Battery[480]={
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xE0,0x30,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x98,0x58,0xD8,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x30,0x60,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x80,0x40,0x20,0x10,0x08,0x04,0x82,0x61,0x18,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xE0,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,
0x18,0x14,0x12,0x11,0x10,0x10,0x10,0x10,0x10,0x16,0x15,0x14,0x14,0x14,0x14,0x14,0x14,0xD4,0x74,0x14,0x04,0x04,0x04,0x84,0x44,0x24,0x14,0x0C,0x04,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x10,0x8C,0x43,0x20,0x10,0x08,0x04,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x03,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x06,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,
0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0D,0x0D,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,
0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x06,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00/*"未命名文件",0*/
};

const UINT8 CODE DisplayEnvelope[2][40]={  //20X12


{0x00,0x00,0xF8,0xFC,0x0E,0x96,0x76,0x66,0xC6,0x86,0xC6,0x66,0x76,0x96,0x0E,0xFC,0xF8,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x07,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
0x06,0x06,0x07,0x03,0x01,0x00,0x00,0x00},/*"未命名文件",0*/

{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}

};

#define  SPI_BUFF_LENTH   80
UINT8 fontBUFF[SPI_BUFF_LENTH];
UINT8 FONT_Get_HwideLhigh8(uint8 charType);
UINT8 Font_Read_DataBytes(uint16 data,uint8 type);
UINT32 FONT_SPI_Address(uint16 data,uint8 type);



#if (HAL_LCD == TRUE)
/**************************************************************************************************
 *                                       LOCAL VARIABLES
 **************************************************************************************************/

//static UINT8 *Lcd_Line1;
void Show_Pattern(const unsigned char CODE *Data_Pointer, unsigned char a, unsigned char b, unsigned char c, unsigned char d);
/**************************************************************************************************
 *                                       FUNCTIONS - API
 **************************************************************************************************/
void HalLcd_HW_Init(void);
void HalLcd_HW_WaitUs(uint16 i);
void HalLcd_HW_Clear(void);
void HalLcd_HW_Control(uint8 cmd);
void HalLcd_HW_Write(uint8 data);
UINT8 HalLcd_HW_Page_GB(uint8 page,uint8 line_x,uint8 offset,charType charType,const uint8 *pdata);
UINT8 HalLcd_HW_Page_ASCII(uint8 page,uint8 line_x,uint8 offset,charType charType,const uint8 *pdata);
UINT8 HalLcd_Page_Char(uint8 page,uint8 line_x,charType charType,const uint16 pdata);
#endif //LCD

/**************************************************************************************************
 * @fn      HalLcdInit
 *
 * @brief   Initilize LCD Service
 *
 * @param   init - pointer to void that contains the initialized value
 *
 * @return  None
 **************************************************************************************************/
void HalLcdInit(void)
{
#if (HAL_LCD == TRUE)
  //Lcd_Line1 = 0;
  HalLcd_HW_Init();
//	test_oled();
#endif
}


void HalLcdTurnOff(void)
{
    //关掉屏电源
    P1SEL &=~(0x20);
    P1DIR |= 0x20;
    P1_5 |= 0x01;

    //将SPI四个IO口设置为输出低，防止漏电到屏上
    P0SEL &=~(0x3A);
    P0DIR |= 0x3A;
    P0_1 =0;
    P0_3 =0;
    P0_4 =0;
    P0_5 =0;
}



/*************************************************************************************************
 *                    LCD EMULATION FUNCTIONS
 *
 * Some evaluation boards are equipped with Liquid Crystal Displays
 * (LCD) which may be used to display diagnostic information. These
 * functions provide LCD emulation, sending the diagnostic strings
 * to Z-Tool via the RS232 serial port. These functions are enabled
 * when the "LCD_SUPPORTED" compiler flag is placed in the makefile.
 *
 * Most applications update both lines (1 and 2) of the LCD whenever
 * text is posted to the device. This emulator assumes that line 1 is
 * updated first (saved locally) and the formatting and send operation
 * is triggered by receipt of line 2. Nothing will be transmitted if
 * only line 1 is updated.
 *
 *************************************************************************************************/

#if (HAL_LCD == TRUE)
/**************************************************************************************************
 *                                    HARDWARE LCD
 **************************************************************************************************/

/**************************************************************************************************
 * @fn      halLcd_ConfigIO
 *
 * @brief   Configure IO lines needed for LCD control.
 *
 * @param   None
 *
 * @return  None
 **************************************************************************************************/
static void halLcd_ConfigIO(void)
{
    P1SEL &=~(0x20);   //LCD电源控制口初始化
//  P1SEL |=(0x20); 
    P1DIR |= 0x20;
    P1_5 = 0x00;

    /* GPIO configuration */
    //HAL_CONFIG_IO_OUTPUT(HAL_LCD_MODE_PORT,  HAL_LCD_MODE_PIN,  1);
    HAL_CONFIG_IO_OUTPUT(HAL_LCD_RESET_PORT, HAL_LCD_RESET_PIN, 1);
    HAL_CONFIG_IO_OUTPUT(HAL_LCD_CS_PORT,    HAL_LCD_CS_PIN,    1);
    HAL_CONFIG_IO_OUTPUT(HAL_LCD_MODE_PORT,  HAL_LCD_MODE_PIN,	1);
//	HAL_CONFIG_IO_OUTPUT(1,  5,	0);
	HAL_CONFIG_IO_OUTPUT(1,  0, 1);

    //HAL_CONFIG_IO_OUTPUT(HAL_FONT_CS_PORT,    HAL_FONT_CS_PIN,    1);
}


/**************************************************************************************************
 * @fn		halLcd_ConfigSPI
 *
 * @brief	Configure SPI lines needed for talking to LCD.
 *
 * @param	None
 *
 * @return	None
 **************************************************************************************************/
static void halLcd_ConfigSPI(void)
{
  /* UART/SPI Peripheral configuration */

   UINT8 baud_exponent;
   UINT8 baud_mantissa;

  /* Set SPI on UART 1 alternative 2 */
//  PERCFG |= 0x02; //FONT
  PERCFG &= ~(0x01); //LCD

  /* Configure clk, master out and master in lines */
  HAL_CONFIG_IO_PERIPHERAL(HAL_LCD_CLK_PORT,  HAL_LCD_CLK_PIN);
  HAL_CONFIG_IO_PERIPHERAL(HAL_LCD_MOSI_PORT, HAL_LCD_MOSI_PIN);
 // HAL_CONFIG_IO_PERIPHERAL(HAL_LCD_MISO_PORT, HAL_LCD_MISO_PIN);
//	//HAL_CONFIG_IO_INPUT(HAL_LCD_MISO_PORT,HAL_LCD_MISO_PIN);
//        HAL_CONFIG_IO_INPUT(0,2);
// P0INP |=(1<<2);  //3-state

 // HAL_CONFIG_IO_PERIPHERAL(HAL_FONT_CLK_PORT,  HAL_FONT_CLK_PIN);
 // HAL_CONFIG_IO_PERIPHERAL(HAL_FONT_MOSI_PORT, HAL_FONT_MOSI_PIN);
 // HAL_CONFIG_IO_PERIPHERAL(HAL_FONT_MISO_PORT, HAL_FONT_MISO_PIN);
  /* Set SPI speed to 1 MHz (the values assume system clk of 32MHz)
   * Confirm on board that this results in 1MHz spi clk.
   */
  baud_exponent = 15;
  baud_mantissa =  0;

  /* Configure SPI */
  U0UCR  = 0x80;	  /* Flush and goto IDLE state. 8-N-1. */
  U0CSR  = 0x00;	  /* SPI mode, master. */
  U0GCR  = HAL_SPI_TRANSFER_MSB_FIRST | HAL_SPI_CLOCK_PHA_0 | HAL_SPI_CLOCK_POL_LO | baud_exponent;
  U0BAUD = baud_mantissa;

}

/**************************************************************************************************
 * @fn		HalLcd_HW_Init
 *
 * @brief	Initilize HW LCD Driver.
 *
 * @param	None
 *
 * @return	None
 **************************************************************************************************/
/*
void test()
{
	unsigned char i=1;
	while (1)
	{
		Menu_UpdateTime(i++);
		Fill_RAM(0x00);
		Menu_UpdateID(12345);
		  Horizontal_Scroll(0x01,0x02,0x04,0x00,0x20);
		  Deactivate_Scroll(); //停止移动
		Fill_RAM(0x00);
		Menu_UpdateDate();
		Fill_RAM(0x00);
                Menu_UpdateBandState(1,1); //连接
                Menu_UpdateWeek();
		Menu_UpdateSOS();
               
                Continuous_Scroll(0x01,0x02,0x05,0x10,0x10,0x10,0x00,0x02);
		Fill_RAM(0x00);
		Menu_UpdateWeather();
		Fill_RAM(0x00);
		Menu_UpdateWeek();
		Menu_UpdateBandState(1,1); //连接
//		Menu_UpdateNoSMS();
		LCD_SPI_END();
		LCD_ACTIVATE_RESET();  //res=0
		set_allpin_down();

		Menu_UpdadeBattery(3);
		Menu_UpdateEnvelope(1);
		Menu_UpdateTumble();
	        Frame();     //边框
	}

}*/
void HalLcd_HW_Init(void)
{

  /* Initialize LCD IO lines */
  halLcd_ConfigIO();

  /* Initialize SPI */
  halLcd_ConfigSPI();

// P0_1 =0;
  HalLcd_HW_WaitUs(10000); // 10 ms

  /* Perform reset */

   OLED_Init_I();
 // test();
	/* Clear the display */
  HalLcd_HW_Clear();

  HalLcd_HW_WaitUs(10000); // 100 ms
}



/**************************************************************************************************
 * @fn      HalLcd_BigChar40*32_StartX
 *
 * @brief
 *
 * @param
 *
 * @return  None
 **************************************************************************************************/
/*void HalLcd_BigChar_StartX(UINT8 line_x,UINT8 page, UINT8 model,const UINT8 CODE * pData, UINT16 len)
{
    HalLcd_HW_Control(LCD_SET_MEM_MODE_REG);
    HalLcd_HW_Control(0x02);

    if(!model || pData == 0)
    {
        return;
    }

    if(line_x > LCD_MAX_LINE_LENGTH)
    {
        //line_x = line_x%128;
        return;
    }

    if(page > LCD_MAX_PAGE_COUNT)
    {
        //page = page%8;
        return;
    }

    for(UINT16 idx = 0; idx < len; idx++)
    {
        HalLcd_HW_Control(((UINT8)(idx/model+line_x))&0x0f);
        HalLcd_HW_Control(((UINT8)((idx/model+line_x)>>4)&0x0f)|0x10);
        HalLcd_HW_Control(0xb0|(idx%model+page));
        HalLcd_HW_Write(*(pData+idx));
    }
}
*/
/**************************************************************************************************
 * @fn      HalLcd_HW_Control
 *
 * @brief   Write 1 command to the LCD
 *
 * @param   uint8 cmd - command to be written to the LCD
 *
 * @return  None
 **************************************************************************************************/
void HalLcd_HW_Control(uint8 cmd)
{

	LCD_SPI_BEGIN();
	LCD_DO_CONTROL();
	LCD_SPI_TX(cmd);
	LCD_SPI_WAIT_RXRDY();
	LCD_SPI_END();

}





uint8 FONT_Get_HwideLhigh8(UINT8 charType)
{
        UINT8  HwideLhigh8=0;

        switch(charType)
            {
                case CHAR_5X7_ASCII:
                    HwideLhigh8 = ((0x05-1)<<4)|0x01;
                    break;
                case CHAR_7X8_ASCII:
                    HwideLhigh8 = ((0x07-1)<<4)|0x01;
                    break;
                case CHAR_6X12_ASCII:
                    HwideLhigh8 = ((0x06-1)<<4)|0x02;
                    break;
               case  CHAR_8X16_ASCII:
                    HwideLhigh8 = ((0x08-1)<<4)|0x02;
                    break;
               case  CHAR_12_ASCII_ARIAL:
                    HwideLhigh8 = ((0x0C-1)<<4)|0x02;
                    break;
               case  CHAR_16_ASCII_ARIAL:
                    HwideLhigh8 = ((0x10-1)<<4)|0x02;
                    break;
                case CHAR_11X12_GB2312:
                    HwideLhigh8 = ((0x0C-1)<<4)|0x02;
                    break;
                case CHAR_15X16_GB2312:
                    HwideLhigh8 = ((0x10-1)<<4)|0x02;
                    break;
                //case CHAR_6X12_GB2312:
                //    HwideLlenth8 = 12;
                //    break;
                //case CHAR_8X16_GBEXPAND:
                //    HwideLlenth8 = 16;
                //    break;

                default:
                    break;

            }
            return HwideLhigh8;
}



uint8 Font_Read_DataBytes(UINT16 data,UINT8 charType)
{
  UINT8 flag=1;
  UINT32 address=0;
  UINT8 *pBUFF=fontBUFF;
  UINT8 HwideLhigh8=0;
  UINT8 charLenth=0;

  HwideLhigh8= FONT_Get_HwideLhigh8(charType);
  charLenth = ((HwideLhigh8>>4)+1)*(HwideLhigh8&0x0f);
  address=  FONT_SPI_Address(data,charType);
  if(((address>=0x67d00)&&(address<=0x67d6f))||(address>=0x7fa33))
  {
        return flag;
  }
  *pBUFF=0x03;
  *(pBUFF+1)=(address>>16)&0xff;
  *(pBUFF+2)=(address>>8)&0xff;
  *(pBUFF+3)=address&0xff;

  FONT_SPI_BEGIN();
  for(UINT8 n=0;n<= charLenth+2;n++)
  {
      FONT_SPI_TX_RX(*(pBUFF+n),*(pBUFF+n+40));
  }

  FONT_SPI_WAIT_RXRDY();
  FONT_SPI_END();
  return 0;
}

uint32 FONT_SPI_Address(UINT16 data,UINT8 type)
{
        UINT32  baseADD=0;
        UINT16  fontcode=0;
        UINT32  address =0x7FFFF;
        UINT32  msb=0;
        UINT32  lsb=0;

        fontcode = data;
        switch(type)
            {
                case CHAR_5X7_ASCII:
                    baseADD=0x3BFC0;
                    if((fontcode >=0x20)&&(fontcode <=0x7E))
                    {
                         address = ( fontcode - 0x20) * 8+baseADD;
                    }
                    break;
                case CHAR_7X8_ASCII:
                    baseADD=0x66C0;
                    if((fontcode >=0x20)&&(fontcode <=0x7E))
                    {
                         address = ( fontcode - 0x20) * 8+baseADD;
                    }
                    break;
                case CHAR_6X12_ASCII:
                    baseADD=0x66D40;
                    if((fontcode >=0x20)&&(fontcode <=0x7E))
                    {
                         address = ( fontcode - 0x20) * 12+baseADD;
                    }
                    break;

				case CHAR_8X16_ASCII:
					baseADD=0x3B7C0;
					if((fontcode >=0x20)&&(fontcode <=0xAAFE))
					{
						 address = ( fontcode - 0x20) * 16+baseADD;
					}
					break;

                case CHAR_8X16_GBEXPAND:
                    baseADD=0x3B7C0;
                    if((fontcode >=0xAAA1)&&(fontcode <=0x7E))
                    {
                         address = ( fontcode - 0xAAA1) * 16+baseADD;
                    }
					else if((fontcode >=0xABA1)&&(fontcode <=0xABC0))
					{
						address = ( fontcode - 0xABA1+94) * 16+baseADD;
					}
                    break;

                case CHAR_11X12_GB2312:
                    baseADD=0x3CF80;
                    msb=fontcode>>8;
                    lsb = fontcode&0xFF;

                    if((msb >=0xA1)&&(msb <=0xA3)&&(lsb <=0xA1))
                    {
                         address = ( msb - 0xA1) * 94 +(lsb-0xA1) *24+baseADD;
                    }
                    else if((msb ==0xa9)&&(lsb>=0xa1))
                    {
                        address = ( 282 +(lsb-0xA1)) *24+baseADD;
                    }
                    else if((msb>=0xb0)&&(msb<=0xf7)&&(lsb>=0xa1))
                    {
                        address = ( (msb-0xb0)*94+((lsb-0xa1)+376)*24) +baseADD;
                    }
                    break;
                case CHAR_15X16_GB2312:
                    baseADD=0;
                    msb=fontcode>>8;
                    lsb = fontcode&0xFF;

                    if((msb==0xA9)&&(lsb >=0xA1))
                    {
                         address = ( 282 +(lsb-0xA1)) *32+baseADD;
                    }
                    else if((msb >=0xa1)&&(msb <=0xa3)&&(lsb>=0xa1))
                    {
                        address = ( (msb -0xa1)*94 +(lsb-0xA1)) *32+baseADD;
                    }
                    else if((msb>=0xb0)&&(msb<=0xf7)&&(lsb>=0xa1))
                    {
                        address =  ((msb-0xb0)*94+(lsb-0xa1)+846)*32+baseADD;
                    }
                    break;
                case CHAR_6X12_GB2312:
                    baseADD=0x66d4c;
                    if((fontcode>=0xaaa1)&&(fontcode>=0xaafe))
                    {

                        address =( fontcode-0xaaa1)*12 +baseADD;
                    }
                    else if((fontcode>=0xaba1)&&(fontcode<=0xabc0))
                    {
                        address =( fontcode-0xaba1 +95)*12 +baseADD;
                    }
                    break;

                default:
                    break;

            }
            return address;
}

/**************************************************************************************************
 * @fn      HalLcd_HW_Write
 *
 * @brief   Write 1 byte to the LCD
 *
 * @param   uint8 data - data to be written to the LCD
 *
 * @return  None
 **************************************************************************************************/
void HalLcd_HW_Write(UINT8 data)
{


	LCD_SPI_BEGIN();
	LCD_DO_WRITE();
	LCD_SPI_TX(data);
	LCD_SPI_WAIT_RXRDY();
	LCD_SPI_END();

}



/**************************************************************************************************
 * @fn      HalLcd_HW_Clear
 *
 * @brief   Clear the HW LCD
 *
 * @param   None
 *
 * @return  None
 **************************************************************************************************/
void HalLcd_HW_Clear(void)
{

	Fill_RAM(0x00);				// Clear Screen
}





uint8 HalLcd_HW_Page_GB(UINT8 page,UINT8 line_x,UINT8 offset,charType charType,const UINT8 *pdata)
{
    UINT8 flag= LCD_SUCCESS;
    UINT8 HwideLhigh8=0;
    UINT8 len = 0;
	UINT16 u16Data = 0;
	UINT8 u8Offset = 0;
	UINT8 lastCharLen = 16;
	page +=1;
    if((page>LCD_MAX_PAGE_COUNT)||(line_x>LCD_MAX_LINE_LENGTH)
        ||(offset+line_x)>LCD_MAX_LINE_LENGTH)
    {
        return  LCD_INVALID_PARAMETER;
    }

    len = strlen((char*)pdata);

    if(line_x+ len > LCD_MAX_LINE_LENGTH)
    {
        return LCD_INVALID_PARAMETER;
    }
    HwideLhigh8=FONT_Get_HwideLhigh8(charType);

    for(UINT8 i = 0; i < len/2 + len%2 + u8Offset/2+u8Offset%2; i++)
    {
		if(*(pdata+i*2-u8Offset) <= 0x7f)
		{
			lastCharLen = 8;
		}

		if(line_x+i*((HwideLhigh8>>4)+1+offset)-u8Offset*8 > LCD_MAX_LINE_LENGTH+1-lastCharLen)
		{
			return flag;
		}

    	if(*(pdata+i*2-u8Offset) <= 0x7f)
    	{
			flag =HalLcd_Page_Char(page,line_x+i*((HwideLhigh8>>4)+1+offset)-u8Offset*8,CHAR_8X16_ASCII,(uint16)*(pdata+i*2-u8Offset));
			u8Offset++;
		}
		else
		{
        	u16Data = *(pdata+i*2-u8Offset)<<8|*(pdata+i*2+1-u8Offset);
			flag =HalLcd_Page_Char(page,line_x+i*((HwideLhigh8>>4)+1+offset)-u8Offset*8,charType,u16Data);//*(pdata+i));
		}
        Continuous_Scroll(0x01,0x02,0x04,0x10,0x10,0x10,0x00,0x02);//滚屏
    }
	Continuous_Scroll(0x01,0x02,0x04,0x10,0x10,0x10,0x00,0x02);//滚屏
	
    return flag;
}

uint8 HalLcd_Page_Char(UINT8 page,UINT8 line_x,charType charType,const UINT16 pdata)
{
    UINT8  flag=1;
    UINT8 HwideLhigh8=0;
    UINT8 charLenth=0;
    if((page > LCD_MAX_PAGE_COUNT)||(line_x > LCD_MAX_LINE_LENGTH))
    {
        return LCD_INVALID_PARAMETER;
    }

	// 2~130
	line_x += led_start_offset;

    flag =Font_Read_DataBytes(pdata,charType);

    if(flag ==0)
    {
        HwideLhigh8=FONT_Get_HwideLhigh8(charType);
        charLenth = ((HwideLhigh8>>4)+1)*(HwideLhigh8&0x0f);

		Set_Start_Page(page);
		Set_Start_Column(line_x);
		for(UINT8 i=0;i<(HwideLhigh8>>4)+1;i++)
		{
			HalLcd_HW_Write(*(fontBUFF+40+4+i));
		}
		
		Set_Start_Page(page+1);
		Set_Start_Column(line_x);
		for(UINT8 i=(HwideLhigh8>>4)+1;i<charLenth;i++)
		{
			HalLcd_HW_Write(*(fontBUFF+40+4+i));
		}
		
    }
    else
    {
        return LCD_GET_FONT_FAULT;
    }
    memset((UINT8 *)fontBUFF, 0, SPI_BUFF_LENTH);
    return LCD_SUCCESS;
}




/**************************************************************************************************
 * @fn      HalLcd_HW_WaitUs
 *
 * @brief   wait for x us. @ 32MHz MCU clock it takes 32 "nop"s for 1 us delay.
 *
 * @param   x us. range[0-65536]
 *
 * @return  None
 **************************************************************************************************/
void HalLcd_HW_WaitUs(UINT16 microSecs)
{
    while(microSecs--)
    {
        /* 32 NOPs == 1 usecs */
        asm("nop"); asm("nop"); asm("nop"); asm("nop"); asm("nop");
        asm("nop"); asm("nop"); asm("nop"); asm("nop"); asm("nop");
        asm("nop"); asm("nop"); asm("nop"); asm("nop"); asm("nop");
        asm("nop"); asm("nop"); asm("nop"); asm("nop"); asm("nop");
        asm("nop"); asm("nop"); asm("nop"); asm("nop"); asm("nop");
        asm("nop"); asm("nop"); asm("nop"); asm("nop"); asm("nop");
        asm("nop"); asm("nop");
    }
}

void LCD_TimePrint(uint8 flash,Time_t time)
{
    uint8 u8Count = flash;
	uint8 offset = led_start_offset+12;

	
	
	Show_Pattern(DisplayNum24X12[time.hour/10],0x02,0x04,offset,0x0C);
	offset +=16;
	Show_Pattern(DisplayNum24X12[time.hour%10],0x02,0x04,offset,0x0C);
	offset +=16;
	if(u8Count%2)
    {
        Show_Pattern(DisplayNum24X12[12],0x02,0x04,offset,0x0C);
		offset +=16;
    }
    else
    {
		Show_Pattern(DisplayNum24X12[13],0x02,0x04,offset,0x0C);
		offset +=16;
    } 
	
	Show_Pattern(DisplayNum24X12[time.min/10],0x02,0x04,offset,0x0C);
	offset +=16;
	Show_Pattern(DisplayNum24X12[time.min%10],0x02,0x04,offset,0x0C);
 
}

void LCD_IDPrint(UINT16 id)
{
    uint8 num = 0;
	uint8 offset = led_start_offset;
	uint16 displayNum = 0;

	Show_Pattern(DisplayNum24X12[10],0x02,0x04,offset,0x0C);
	offset += 12;
	Show_Pattern(DisplayNum24X12[11],0x02,0x04,offset,0x0C);
	offset += 12;
	Show_Pattern(DisplayNum24X12[12],0x02,0x04,offset,0x0C);
	offset += 12;
	for(uint8 idx = 0; idx <5;idx++)
	{
		uint8 sIdx = idx;
		uint16 model = 1;
		while(sIdx < 4)
		{
			model *= 10;
			sIdx++;
		}

		if(id/model)
		{
			num = idx;
			break;
		}

	}

	switch(num)
	{
	   case 0:
		//; *10000
		displayNum = id/10000;
		Show_Pattern(DisplayNum24X12[displayNum],0x02,0x04,offset,0x0C);
		offset += 12;
	   case 1:
		//; *1000
		displayNum = (id%10000)/1000;
		Show_Pattern(DisplayNum24X12[displayNum],0x02,0x04,offset,0x0C);
		offset += 12;

	   case 2:
		//; *100
		displayNum = (id%1000)/100;
		Show_Pattern(DisplayNum24X12[displayNum],0x02,0x04,offset,0x0C);
		offset += 12;
	   case 3:
		//; *10
		displayNum = (id%100)/10;
		Show_Pattern(DisplayNum24X12[displayNum],0x02,0x04,offset,0x0C);
		offset += 12;
	   case 4:
		//; *1
		displayNum = id%10;
		Show_Pattern(DisplayNum24X12[displayNum],0x02,0x04,offset,0x0C);

		default:
			break;
	}



}


void LCD_DatePrint(Date_t date)
{
	uint8 offset = led_start_offset+10;
	Show_Pattern(DisplayNum24X12[date.mon/10],0x02,0x04,offset,0x0C);
	offset +=12;
	Show_Pattern(DisplayNum24X12[date.mon%10],0x02,0x04,offset,0x0C);
	offset +=12;
	Show_Pattern(DisplayDate24X16[0],0x02,0x04,offset,0x10);  //月
	offset +=16;

	Show_Pattern(DisplayNum24X12[date.day/10],0x02,0x04,offset,0x0C);
	offset +=12;
	Show_Pattern(DisplayNum24X12[date.day%10],0x02,0x04,offset,0x0C);
	offset +=12;
	Show_Pattern(DisplayDate24X16[1],0x02,0x04,offset,0x10);  //日

}

void LCD_SOSPrint()
{
    uint8 offset = led_start_offset+16;
	static uint8 u8Count = 0;
    if(++u8Count%2)
    {
		Show_Pattern(DisplaySOS24X16[0],0x02,0x04,offset,0x10);
		offset +=24;
		Show_Pattern(DisplaySOS24X16[1],0x02,0x04,offset,0x10);
		offset +=24;
		Show_Pattern(DisplaySOS24X16[0],0x02,0x04,offset,0x10);
     
    }
    else
    {
		Show_Pattern(DisplaySOS24X16[2],0x02,0x04,offset,0x10);
		offset +=24;
		Show_Pattern(DisplaySOS24X16[2],0x02,0x04,offset,0x10);
		offset +=24;
		Show_Pattern(DisplaySOS24X16[2],0x02,0x04,offset,0x10);
    }
}

void LCD_WeatherPrint()
{
	uint8 offset = led_start_offset+12;

	Show_Pattern(DisplayWeather24X16[0],0x02,0x04,offset,0x10);
	offset +=0x14;
	Show_Pattern(DisplayWeather24X16[1],0x02,0x04,offset,0x10);
	offset +=0x14;
	Show_Pattern(&Char24X12_COLON[0],0x02,0x04,offset,0x0C);
	offset +=0x10;
	Show_Pattern(DisplayWeather24X16[2],0x02,0x04,offset,0x10);

}

void Menu_UpdateTime(uint8 flash)
{
    Time_t time;

	time = GetTime();
    //week = GetWeek();
    LCD_TimePrint(flash,time);
}

void Menu_UpdateID(uint16 id)
{
    LCD_IDPrint(id);
}

void Menu_UpdateDate(void)
{
    Date_t date;
    date = GetDate();
    LCD_DatePrint(date);
}

void Menu_UpdateSOS(void)
{
    LCD_SOSPrint();
}

void Menu_UpdateWeather()
{
    LCD_WeatherPrint();
}

void Menu_UpdateWeek()
{
    UINT8 week;
	uint8 offset = led_start_offset+60;
    week = GetWeek();
	
	Show_Pattern(DisplayWeek16X8[0],0x00,0x01,offset,0x0C);
	offset +=0x0C;
	Show_Pattern(DisplayWeek16X8[1],0x00,0x01,offset,0x0C);
	offset +=0x0C;
	Show_Pattern(DisplayWeek16X8[week+2],0x00,0x01,offset,0x0C);

}

void Menu_UpdateTumble(void) //跌倒
{
	uint8 offset = led_start_offset+6;

	for(uint8 i = 0; i<2; i++)
	{
		Show_Pattern(DisplayTumble24X24[i],0x02,0x04,offset,0x18);
		offset+=0x18;
	}
	for(uint8 i = 0; i< 3; i++){
		Show_Pattern(&Char24X12_GANT[0],0x02,0x04,offset,0x0C);
		offset+=0x0C;
	}
}

void Menu_UpdateBandState(uint8 flash,uint8 status) 
{
   uint8 i = flash;

	//BAND_CONNECT
	if(status == 0)
	{
		i = 0;
	}

    if(i%2)
    {
		Show_Pattern(DisplayBandConnect[0],0x00,0x01,52,0x10);  //电量后面一点
    }
    else
    {
        Show_Pattern(DisplayBandConnect[1],0x00,0x01,52,0x10); 
    }
}

void Menu_UpdateEnvelope(uint8 flash)
{
    uint8 i = flash;
	uint8 offset = led_start_offset+38;

    if(i%2)
    {
    	Show_Pattern(DisplayEnvelope[0],0x00,0x01,offset,0x14);  //邮件提示
    }
    else
    {
        Show_Pattern(DisplayEnvelope[0],0x00,0x01,offset,0x14);
    }
}


void Menu_UpdateNoSMS(void)
{
	uint8 offset = led_start_offset;

	for(uint8 i = 0; i< 4; i++)
	{
		offset =led_start_offset+i*25;

		Show_Pattern(DisplayNoSMS24X24[i],0x02,0x04,offset,0x18);
	}

}

void Menu_UpdadeBattery(UINT8 BatteryLevel)
{
  
  static uint8  i = 0;
  uint8 offset = led_start_offset;
  
  if((P0_0 == 1) && (P0_6 == 0))  //charging
  {
    if(BatteryLevel >= 5)
    {
      Show_Pattern(&Char96X40_Battery[0],0x00,0x04,offset,0x60);
    }
    else
    {
    
      Show_Pattern(Char20X16_Battery[i++%5],0x00,0x01,offset,0x14);
    }
  }
  else if((P0_0 == 0) && (P0_6 == 1))   //full
  {
    if(BatteryLevel >= 5)
    {
    
          Show_Pattern(&Char96X40_Battery[0],0x00,0x04,offset,0x60);
    }
    else
    {
    
          Show_Pattern(Char20X16_Battery[4],0x00,0x01,offset,0x14);
    }
  }
  else
  {
  
    Show_Pattern(Char20X16_Battery[BatteryLevel],0x00,0x01,offset,0x14);
  }

}

bool IsBatteryCharge()
{
    if((P0_0 == 0) && (P0_6 == 0))
    {
        return false;
    }

    else
    {
        return true;

    }
}

#endif


/**************************************************************************************************
**************************************************************************************************/


//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//  Show Pattern (Partial or Full Screen)
//
//    a: Start Page
//    b: End Page
//    c: Start Column
//    d: Total Columns
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
void Show_Pattern(const unsigned char CODE *Data_Pointer, unsigned char a, unsigned char b, unsigned char c, unsigned char d)
{
const unsigned char CODE *Src_Pointer;
unsigned char i,j;

	Src_Pointer=Data_Pointer;
	for(i=a;i<(b+1);i++)
	{
		Set_Start_Page(i);
		Set_Start_Column(c);

		for(j=0;j<d;j++)
		{
			Write_Data(*Src_Pointer);
			Src_Pointer++;
		}
	}
}


void Display_SMS_Time(Time_t time,Date_t date,uint8 index)
{
	uint8 offset = 1;
    //    time.hour =time.min=date.day=date.mon=11;
	HalLcd_Page_Char(0,offset,CHAR_6X12_ASCII,(uint16)('0'+index));
	offset += 6;	
	HalLcd_Page_Char(0,offset,CHAR_6X12_ASCII,(uint16)('-'));
	offset += 6;	
	HalLcd_Page_Char(0,offset,CHAR_6X12_ASCII,(uint16)('0'+(time.hour)/10));
	offset += 6;
	HalLcd_Page_Char(0,offset,CHAR_6X12_ASCII,(uint16)('0'+(time.hour)%10));
	offset += 5;
	HalLcd_Page_Char(0,offset,CHAR_6X12_ASCII,(uint16)(':'));
	offset += 5;
	HalLcd_Page_Char(0,offset,CHAR_6X12_ASCII,(uint16)('0'+(time.min)/10));
	offset += 6;
	HalLcd_Page_Char(0,offset,CHAR_6X12_ASCII,(uint16)('0'+(time.min)%10));	
	offset += 12;
	
	HalLcd_Page_Char(0,offset,CHAR_6X12_ASCII,(uint16)('0'+date.mon/10));	
	offset += 6;
	HalLcd_Page_Char(0,offset,CHAR_6X12_ASCII,(uint16)('0'+date.mon%10));	
	offset += 6;	
	Show_Pattern(DisplayDate10X12[0],0x00,0x01,offset+led_start_offset,0x0A);  //月
	offset += 10;
    HalLcd_Page_Char(0,offset,CHAR_6X12_ASCII,(uint16)('0'+date.day/10));	
    offset += 6;
    HalLcd_Page_Char(0,offset,CHAR_6X12_ASCII,(uint16)('0'+date.day%10));	
	offset += 6;
	Show_Pattern(DisplayDate10X12[1],0x00,0x01,offset+led_start_offset,0x0A);   //日
	offset +=10;
	HalLcd_Page_Char(0,offset,CHAR_6X12_ASCII,(uint16)(':'));	

	
}
 //休眠时启用
void set_allpin_down(void){ 
	Fill_RAM(0x00);  //D0,D1=0

	LCD_DO_CONTROL(); //D/C# =0

	LCD_ACTIVATE_RESET();  //res=0
	//LCD_SPI_END(); 
	LCD_SPI_BEGIN();//cs=0

	P1_5 = 1;        //power down
	P1_0 = 0;
}
void set_allpin_up(void){  //醒来时启用
	P1_5 = 0;        //power open
//    LCD_SPI_BEGIN();
    LCD_SPI_END(); 
   // LCD_SPI_BEGIN();
	LCD_RELEASE_RESET();
}

