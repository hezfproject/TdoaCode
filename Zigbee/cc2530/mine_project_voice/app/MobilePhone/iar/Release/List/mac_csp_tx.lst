###############################################################################
#                                                                             #
# IAR C/C++ Compiler V7.60.1.40026 for 8051             23/Oct/2018  17:27:18 #
# Copyright (C) 2004-2010 IAR Systems AB.                                     #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  E:\p4\main\Zigbee\cc2530\mine_project_voice\third_ #
#                          party\TIMAC-CC2530-1.3.1\Components\mac\low_level\ #
#                          srf04\single_chip\mac_csp_tx.c                     #
#    Command line       =  E:\p4\main\Zigbee\cc2530\mine_project_voice\third_ #
#                          party\TIMAC-CC2530-1.3.1\Components\mac\low_level\ #
#                          srf04\single_chip\mac_csp_tx.c -D xSMS_TEMPLATE    #
#                          -D MENU_CLOCKFORMAT -D CELLSWITCH_DEBUG -D         #
#                          MP_INFORMATION -D HOLD_AUTO_START -D SMS_SENDBOX   #
#                          -D NEW_MENU_LIB -D WATCHDOG=TRUE -D                #
#                          NEW_DOUBLE_NVID_OP -D AUDIO_SERIAL -D              #
#                          NWK_AUTO_POLL -D OSC32K_CRYSTAL_INSTALLED=FALSE    #
#                          -D xAUDIO_TEST -D xSINGLE_AUDIO_TEST -D            #
#                          xMULTIAUDIO_TEST -D xREFLECTOR -D xLCD_SUPPORTED   #
#                          -D HAL_LCD=FALSE -D HAL_AUDIO=TRUE -D              #
#                          HAL_SPI=FALSE -D HAL_UART=FALSE -D HAL_LED=FALSE   #
#                          -D HAL_AES=FALSE -D HAL_KEY=TRUE -D                #
#                          IDX_THRESHOLD=12 -D xMACNODEBUG -D                 #
#                          xMAC_NO_PARAM_CHECK -D HAL_AUDIO=TRUE -D           #
#                          HAL_DMA=TRUE -D HAL_AES=FALSE -D                   #
#                          MAC_CFG_TX_DATA_MAX=8 -D MAC_CFG_TX_MAX=12 -D      #
#                          MAC_CFG_RX_MAX=8 -lcN E:\p4\main\Zigbee\cc2530\min #
#                          e_project_voice\app\MobilePhone\iar\Release\List\  #
#                          -lb E:\p4\main\Zigbee\cc2530\mine_project_voice\ap #
#                          p\MobilePhone\iar\Release\List\ -o                 #
#                          E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\Release\Obj\ -e                      #
#                          --require_prototypes --no_unroll --no_inline       #
#                          --no_code_motion --debug --core=plain --dptr=16,1  #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I E:\p4\main\Zigbee\cc2530\mine_project_voice\app #
#                          \MobilePhone\iar\..\src\ -I                        #
#                          E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\..\src\MenuLib\ -I                   #
#                          E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\..\src\MenuLib\util\ -I              #
#                          E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\..\..\..\third_party\TIMAC-CC2530-1. #
#                          3.1\COMPONENTS\MAC\INCLUDE\ -I                     #
#                          E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\..\..\..\third_party\TIMAC-CC2530-1. #
#                          3.1\COMPONENTS\MAC\HIGH_LEVEL\ -I                  #
#                          E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\..\..\..\third_party\TIMAC-CC2530-1. #
#                          3.1\COMPONENTS\MAC\LOW_LEVEL\ -I                   #
#                          E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\..\..\..\third_party\TIMAC-CC2530-1. #
#                          3.1\COMPONENTS\MAC\LOW_LEVEL\SRF04\ -I             #
#                          E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\..\..\..\third_party\TIMAC-CC2530-1. #
#                          3.1\COMPONENTS\MAC\LOW_LEVEL\SRF04\SINGLE_CHIP\    #
#                          -I E:\p4\main\Zigbee\cc2530\mine_project_voice\app #
#                          \MobilePhone\iar\..\..\..\third_party\TIMAC-CC2530 #
#                          -1.3.1\COMPONENTS\OSAL\INCLUDE\ -I                 #
#                          E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\..\..\..\third_party\TIMAC-CC2530-1. #
#                          3.1\COMPONENTS\OSAL\MCU\CC2530\ -I                 #
#                          E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\..\..\..\third_party\TIMAC-CC2530-1. #
#                          3.1\COMPONENTS\SERVICES\SADDR\ -I                  #
#                          E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\..\..\..\third_party\TIMAC-CC2530-1. #
#                          3.1\COMPONENTS\SERVICES\SDATA\ -I                  #
#                          E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\..\..\..\third_party\TIMAC-CC2530-1. #
#                          3.1\COMPONENTS\MT\ -I E:\p4\main\Zigbee\cc2530\min #
#                          e_project_voice\app\MobilePhone\iar\..\..\..\..\.. #
#                          \..\common\ -I E:\p4\main\Zigbee\cc2530\mine_proje #
#                          ct_voice\app\MobilePhone\iar\..\..\..\..\..\common #
#                          \lcd\ -I E:\p4\main\Zigbee\cc2530\mine_project_voi #
#                          ce\app\MobilePhone\iar\..\..\..\..\..\..\common\2g #
#                          \ -I E:\p4\main\Zigbee\cc2530\mine_project_voice\a #
#                          pp\MobilePhone\iar\..\..\..\..\..\..\ -I           #
#                          E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\..\..\..\driver\ -I                  #
#                          E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\..\..\..\util\ -I                    #
#                          E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\..\..\..\driver\include\ -I          #
#                          E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\..\..\..\driver\common\ -I           #
#                          E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\..\..\..\driver\MobilePhone\ -I      #
#                          E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\..\..\..\driver\MobilePhone\audio\   #
#                          -I E:\p4\main\Zigbee\cc2530\mine_project_voice\app #
#                          \MobilePhone\iar\..\..\..\driver\MobilePhone\commo #
#                          n\ -I E:\p4\main\Zigbee\cc2530\mine_project_voice\ #
#                          app\MobilePhone\iar\..\..\..\driver\MobilePhone\ke #
#                          y\ -I E:\p4\main\Zigbee\cc2530\mine_project_voice\ #
#                          app\MobilePhone\iar\..\..\..\driver\MobilePhone\lc #
#                          d\ -I E:\p4\main\Zigbee\cc2530\mine_project_voice\ #
#                          app\MobilePhone\iar\..\..\..\driver\MobilePhone\io #
#                          expand\ -I "C:\Program Files\IAR Systems\Embedded  #
#                          Workbench 5.4\8051\INC\" -I "C:\Program Files\IAR  #
#                          Systems\Embedded Workbench 5.4\8051\INC\CLIB\"     #
#                          -Ohs                                               #
#    List file          =  E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\Release\List\mac_csp_tx.lst          #
#    Object file        =  E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\Release\Obj\mac_csp_tx.r51           #
#                                                                             #
#                                                                             #
###############################################################################

E:\p4\main\Zigbee\cc2530\mine_project_voice\third_party\TIMAC-CC2530-1.3.1\Components\mac\low_level\srf04\single_chip\mac_csp_tx.c
      1          /**************************************************************************************************
      2            Filename:       mac_csp_tx.c
      3            Revised:        $Date: 2011/03/14 18:43:37 $
      4            Revision:       $Revision: 1.1 $
      5          
      6            Description:    Describe the purpose and contents of the file.
      7          
      8          
      9            Copyright 2006-2010 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /* ------------------------------------------------------------------------------------------------
     41           *                                           Includes
     42           * ------------------------------------------------------------------------------------------------
     43           */
     44          
     45          /* hal */
     46          #include "hal_types.h"
     47          #include "hal_mcu.h"
     48          
     49          /* high-level */
     50          #include "mac_spec.h"
     51          #include "mac_pib.h"
     52          
     53          /* exported low-level */
     54          #include "mac_low_level.h"
     55          
     56          /* low-level specific */
     57          #include "mac_csp_tx.h"
     58          #include "mac_tx.h"
     59          #include "mac_rx.h"
     60          #include "mac_rx_onoff.h"
     61          
     62          /* target specific */
     63          #include "mac_radio_defs.h"
     64          
     65          /* debug */
     66          #include "mac_assert.h"
     67          
     68          
     69          /* ------------------------------------------------------------------------------------------------
     70           *                                   CSP Defines / Macros
     71           * ------------------------------------------------------------------------------------------------
     72           */
     73          /* immediate strobe commands */
     74          #define ISSTART     0xE1
     75          #define ISSTOP      0xE2
     76          #define ISCLEAR     0xFF
     77          
     78          /* strobe processor instructions */
     79          #define SKIP(s,c)   (0x00 | (((s) & 0x07) << 4) | ((c) & 0x0F))   /* skip 's' instructions if 'c' is true  */
     80          #define WHILE(c)    SKIP(0,c)              /* pend while 'c' is true (derived instruction)        */
     81          #define WAITW(w)    (0x80 | ((w) & 0x1F))  /* wait for 'w' number of MAC timer overflows          */
     82          #define WEVENT1     (0xB8)                 /* wait for MAC timer compare                          */
     83          #define WAITX       (0xBC)                 /* wait for CSPX number of MAC timer overflows         */
     84          #define LABEL       (0xBB)                 /* set next instruction as start of loop               */
     85          #define RPT(c)      (0xA0 | ((c) & 0x0F))  /* if condition is true jump to last label             */
     86          #define INT         (0xBA)                 /* assert IRQ_CSP_INT interrupt                        */
     87          #define INCY        (0xC1)                 /* increment CSPY                                      */
     88          #define INCMAXY(m)  (0xC8 | ((m) & 0x07))  /* increment CSPY but not above maximum value of 'm'   */
     89          #define DECY        (0xC4)                 /* decrement CSPY                                      */
     90          #define DECZ        (0xC5)                 /* decrement CSPZ                                      */
     91          #define RANDXY      (0xBD)                 /* load the lower CSPY bits of CSPX with random value  */
     92          
     93          /* strobe processor command instructions */
     94          #define SSTOP       (0xD2)    /* stop program execution                                      */
     95          #define SNOP        (0xD0)    /* no operation                                                */
     96          #define STXCAL      (0xDC)    /* enable and calibrate frequency synthesizer for TX           */
     97          #define SRXON       (0xD3)    /* turn on receiver                                            */
     98          #define STXON       (0xD9)    /* transmit after calibration                                  */
     99          #define STXONCCA    (0xDA)    /* transmit after calibration if CCA indicates clear channel   */
    100          #define SRFOFF      (0xDF)    /* turn off RX/TX                                              */
    101          #define SFLUSHRX    (0xDD)    /* flush receive FIFO                                          */
    102          #define SFLUSHTX    (0xDE)    /* flush transmit FIFO                                         */
    103          #define SACK        (0xD6)    /* send ACK frame                                              */
    104          #define SACKPEND    (0xD7)    /* send ACK frame with pending bit set                         */
    105          
    106          /* conditions for use with instructions SKIP and RPT */
    107          #define C_CCA_IS_VALID        0x00
    108          #define C_SFD_IS_ACTIVE       0x01
    109          #define C_CPU_CTRL_IS_ON      0x02
    110          #define C_END_INSTR_MEM       0x03
    111          #define C_CSPX_IS_ZERO        0x04
    112          #define C_CSPY_IS_ZERO        0x05
    113          #define C_CSPZ_IS_ZERO        0x06
    114          #define C_RSSI_IS_VALID       0x07
    115          
    116          /* negated conditions for use with instructions SKIP and RPT */
    117          #define C_NEGATE(c)   ((c) | 0x08)
    118          #define C_CCA_IS_INVALID      C_NEGATE(C_CCA_IS_VALID)
    119          #define C_SFD_IS_INACTIVE     C_NEGATE(C_SFD_IS_ACTIVE)
    120          #define C_CPU_CTRL_IS_OFF     C_NEGATE(C_CPU_CTRL_IS_ON)
    121          #define C_NOT_END_INSTR_MEM   C_NEGATE(C_END_INSTR_MEM)
    122          #define C_CSPX_IS_NON_ZERO    C_NEGATE(C_CSPX_IS_ZERO)
    123          #define C_CSPY_IS_NON_ZERO    C_NEGATE(C_CSPY_IS_ZERO)
    124          #define C_CSPZ_IS_NON_ZERO    C_NEGATE(C_CSPZ_IS_ZERO)
    125          #define C_RSSI_IS_INVALID     C_NEGATE(C_RSSI_IS_VALID)
    126          
    127          
    128          /* ------------------------------------------------------------------------------------------------
    129           *                                         Defines
    130           * ------------------------------------------------------------------------------------------------
    131           */
    132          
    133          /* CSPZ return values from CSP program */
    134          #define CSPZ_CODE_TX_DONE           0
    135          #define CSPZ_CODE_CHANNEL_BUSY      1
    136          #define CSPZ_CODE_TX_ACK_TIME_OUT   2
    137          
    138          
    139          /* ------------------------------------------------------------------------------------------------
    140           *                                     Local Programs
    141           * ------------------------------------------------------------------------------------------------
    142           */
    143          static void  cspPrepForTxProgram(void);
    144          static void  cspWeventSetTriggerNow(void);
    145          static void  cspWeventSetTriggerSymbols(uint8 symbols);
    146          static uint8 cspReadCountSymbols(void);
    147          
    148          
    149          
    150          /* ------------------------------------------------------------------------------------------------
    151           *                                          Macros
    152           * ------------------------------------------------------------------------------------------------
    153           */
    154          #define CSP_STOP_AND_CLEAR_PROGRAM()          st( RFST = ISSTOP; RFST = ISCLEAR; )
    155          #define CSP_START_PROGRAM()                   st( RFST = ISSTART; )
    156          
    157          /*
    158           *  These macros improve readability of using T2CMP in conjunction with WEVENT.
    159           *
    160           *  The timer2 compare, T2CMP, only compares one byte of the 16-bit timer register.
    161           *  It is configurable and has been set to compare against the upper byte of the timer value.
    162           *  The CSP instruction WEVENT waits for the timer value to be greater than or equal
    163           *  the value of T2CMP.
    164           *
    165           *  Reading the timer value is done by reading the low byte first.  This latches the
    166           *  high byte.  A trick with the ternary operator is used by a macro below to force a
    167           *  read of the low byte when returning the value of the high byte.
    168           *
    169           *  CSP_WEVENT_SET_TRIGGER_NOW()      - sets the WEVENT1 trigger point at the current timer count
    170           *  CSP_WEVENT_SET_TRIGGER_SYMBOLS(x) - sets the WEVENT1 trigger point in symbols
    171           *  CSP_WEVENT_READ_COUNT_SYMBOLS()   - reads the current timer count in symbols
    172           */
    173          #define T2THD_TICKS_PER_SYMBOL                (MAC_RADIO_TIMER_TICKS_PER_SYMBOL() >> 8)
    174          
    175          #define CSP_WEVENT_CLEAR_TRIGGER()            st( T2IRQF = ~TIMER2_COMPARE1F; )
    176          #define CSP_WEVENT_SET_TRIGGER_NOW()          cspWeventSetTriggerNow()
    177          #define CSP_WEVENT_SET_TRIGGER_SYMBOLS(x)     cspWeventSetTriggerSymbols(x)
    178          #define CSP_WEVENT_READ_COUNT_SYMBOLS()       cspReadCountSymbols()
    179          
    180          /*
    181           *  Number of bits used for aligning a slotted transmit to the backoff count (plus
    182           *  derived values).  There are restrictions on this value.  Compile time integrity
    183           *  checks will catch an illegal setting of this value.  A full explanation accompanies
    184           *  this compile time check (see bottom of this file).
    185           */
    186          #define SLOTTED_TX_MAX_BACKOFF_COUNTDOWN_NUM_BITS     4
    187          #define SLOTTED_TX_MAX_BACKOFF_COUNTDOWN              (1 << SLOTTED_TX_MAX_BACKOFF_COUNTDOWN_NUM_BITS)
    188          #define SLOTTED_TX_BACKOFF_COUNT_ALIGN_BIT_MASK       (SLOTTED_TX_MAX_BACKOFF_COUNTDOWN - 1)
    189          
    190          
    191          /**************************************************************************************************
    192           * @fn          macCspTxReset
    193           *
    194           * @brief       Reset the CSP.  Immediately halts any running program.
    195           *
    196           * @param       none
    197           *
    198           * @return      none
    199           **************************************************************************************************
    200           */
    201          MAC_INTERNAL_API void macCspTxReset(void)
    202          {
    203            MAC_MCU_CSP_STOP_DISABLE_INTERRUPT();
    204            MAC_MCU_CSP_INT_DISABLE_INTERRUPT();
    205            CSP_STOP_AND_CLEAR_PROGRAM();
    206          }
    207          
    208          
    209          /*=================================================================================================
    210           * @fn          cspWeventSetTriggerNow
    211           *
    212           * @brief       sets the WEVENT1 trigger point at the current timer count
    213           *
    214           * @param       none
    215           *
    216           * @return      symbols
    217           *=================================================================================================
    218           */
    219          static void cspWeventSetTriggerNow(void)
    220          {
    221            halIntState_t  s;
    222            uint8          temp0, temp1;
    223          
    224            /* Clear the compare interrupt flag for debugging purpose. */
    225            CSP_WEVENT_CLEAR_TRIGGER();
    226          
    227            /* copy current timer count to compare */
    228            HAL_ENTER_CRITICAL_SECTION(s);
    229            MAC_MCU_T2_ACCESS_COUNT_VALUE();
    230            temp0 = T2M0;
    231            temp1 = T2M1;
    232          
    233            /* MAC timer bug on the cc2530 PG1 made it impossible to use
    234             * compare = 0 for both the timer and the overflow counter.
    235             */
    236            if ((macChipVersion <= REV_B) && (temp0 == 0) && (temp1 == 0))
    237            {
    238              temp0++;
    239            }
    240          
    241            MAC_MCU_T2_ACCESS_CMP1_VALUE();
    242            T2M0 = temp0;
    243            T2M1 = temp1;
    244            HAL_EXIT_CRITICAL_SECTION(s);
    245          }
    246          
    247          
    248          /*=================================================================================================
    249           * @fn          cspWeventSetTriggerSymbols
    250           *
    251           * @brief       sets the WEVENT1 trigger point in symbols
    252           *
    253           * @param       symbols
    254           *
    255           * @return      none
    256           *=================================================================================================
    257           */
    258          static void cspWeventSetTriggerSymbols(uint8 symbols)
    259          {
    260            halIntState_t  s;
    261            uint16         cmp;
    262          
    263            MAC_ASSERT(symbols <= MAC_A_UNIT_BACKOFF_PERIOD);
    264          
    265            /* Clear the compare interrupt flag for debugging purpose. */
    266            CSP_WEVENT_CLEAR_TRIGGER();
    267          
    268            HAL_ENTER_CRITICAL_SECTION(s);
    269            MAC_MCU_T2_ACCESS_CMP1_VALUE();
    270            cmp  = (symbols) * MAC_RADIO_TIMER_TICKS_PER_SYMBOL();
    271          
    272            /* MAC timer bug on the cc2530 PG1 made it impossible to use
    273             * compare = 0 for both the timer and the overflow counter.
    274             */
    275            if ((macChipVersion <= REV_B) && (cmp == 0))
    276            {
    277              cmp++;
    278            }
    279            T2M0 = (cmp & 0xFF);
    280            T2M1 = (cmp >> 8);
    281            HAL_EXIT_CRITICAL_SECTION(s);
    282          }
    283          
    284          
    285          /*=================================================================================================
    286           * @fn          cspReadCountSymbols
    287           *
    288           * @brief       reads the current timer count in symbols
    289           *
    290           * @param       none
    291           *
    292           * @return      symbols
    293           *=================================================================================================
    294           */
    295          static uint8 cspReadCountSymbols(void)
    296          {
    297            uint8          countLow, countHigh;
    298            halIntState_t  s;
    299          
    300            HAL_ENTER_CRITICAL_SECTION(s);
    301            MAC_MCU_T2_ACCESS_COUNT_VALUE();
    302            countLow  = T2M0;
    303            countHigh = T2M1;
    304            HAL_EXIT_CRITICAL_SECTION(s);
    305          
    306            return (((countHigh << 8) | countLow) / MAC_RADIO_TIMER_TICKS_PER_SYMBOL());
    307          }
    308          
    309          
    310          /*=================================================================================================
    311           * @fn          cspPrepForTxProgram
    312           *
    313           * @brief       Prepare and initialize for transmit CSP program.
    314           *              Call *before* loading the CSP program!
    315           *
    316           * @param       none
    317           *
    318           * @return      none
    319           *=================================================================================================
    320           */
    321          static void cspPrepForTxProgram(void)
    322          {
    323            MAC_ASSERT(!(RFIRQM1 & IM_CSP_STOP)); /* already an active CSP program */
    324          
    325            /* set CSP EVENT1 to T2 CMP1 */
    326            MAC_MCU_CONFIG_CSP_EVENT1();
    327          
    328            /* set up parameters for CSP transmit program */
    329            CSPZ = CSPZ_CODE_CHANNEL_BUSY;
    330          
    331            /* clear the currently loaded CSP, this generates a stop interrupt which must be cleared */
    332            CSP_STOP_AND_CLEAR_PROGRAM();
    333            MAC_MCU_CSP_STOP_CLEAR_INTERRUPT();
    334            MAC_MCU_CSP_INT_CLEAR_INTERRUPT();
    335          }
    336          
    337          
    338          /**************************************************************************************************
    339           * @fn          macCspTxPrepCsmaUnslotted
    340           *
    341           * @brief       Prepare CSP for "Unslotted CSMA" transmit.  Load CSP program and set CSP parameters.
    342           *
    343           * @param       none
    344           *
    345           * @return      none
    346           **************************************************************************************************
    347           */
    348          MAC_INTERNAL_API void macCspTxPrepCsmaUnslotted(void)
    349          {
    350            cspPrepForTxProgram();
    351          
    352            /*----------------------------------------------------------------------
    353             *  Load CSP program :  Unslotted CSMA transmit
    354             */
    355          
    356            /*
    357             *  Wait for X number of backoffs, then wait for intra-backoff count
    358             *  to reach value set for WEVENT1.
    359             */
    360            RFST = WAITX;
    361            RFST = WEVENT1;
    362          
    363            /* wait until RSSI is valid */
    364            RFST = WHILE(C_RSSI_IS_INVALID);
    365          
    366            /* sample CCA, if it fails exit from here, CSPZ indicates result */
    367            RFST = SKIP(1, C_CCA_IS_VALID);
    368            RFST = SSTOP;
    369          
    370            /* CSMA has passed so transmit (actual frame starts one backoff from when strobe is sent) */
    371            RFST = STXON;
    372          
    373            /*
    374             *  Wait for the start of frame delimiter of the transmitted frame.  If SFD happens to
    375             *  already be active when STXON is strobed, it gets forced low.  How long this takes
    376             *  though, is not certain.  For bulletproof operation, the first step is to wait
    377             *  until SFD is inactive (which should be very fast if even necessary), and then wait
    378             *  for it to go active.
    379             */
    380            RFST = WHILE(C_SFD_IS_ACTIVE);
    381            RFST = WHILE(C_SFD_IS_INACTIVE);
    382          
    383            /*
    384             *  Record the timestamp.  The INT instruction causes an interrupt to fire.
    385             *  The ISR for this interrupt records the timestamp (which was just captured
    386             *  when SFD went high).
    387             */
    388            RFST = INT;
    389          
    390            /*
    391             *  Wait for SFD to go inactive which is the end of transmit.  Decrement CSPZ to indicate
    392             *  the transmit was successful.
    393             */
    394            RFST = WHILE(C_SFD_IS_ACTIVE);
    395            RFST = DECZ;
    396          
    397            /*
    398             * CC2530 requires SSTOP to generate CSP_STOP interrupt.
    399             */
    400            RFST = SSTOP;
    401          }
    402          
    403          
    404          /**************************************************************************************************
    405           * @fn          macCspTxPrepCsmaSlotted
    406           *
    407           * @brief       Prepare CSP for "Slotted CSMA" transmit.  Load CSP program and set CSP parameters.
    408           *
    409           * @param       none
    410           *
    411           * @return      none
    412           **************************************************************************************************
    413           */
    414          MAC_INTERNAL_API void macCspTxPrepCsmaSlotted(void)
    415          {
    416            cspPrepForTxProgram();
    417          
    418            /*----------------------------------------------------------------------
    419             *  Load CSP program :  Slotted CSMA transmit
    420             */
    421          
    422            /* wait for X number of backoffs */
    423            RFST = WAITX;
    424            
    425            /* sample RSSI, if it is valid then skip one extra backoff. */
    426            RFST = SKIP(1, C_RSSI_IS_VALID);
    427            
    428            /* wait for one backoff to guarantee receiver has been on at least that long */
    429            RFST = WAITW(1);
    430          
    431            /* sample CCA, if it fails exit from here, CSPZ indicates result */
    432            RFST = SKIP(1, C_CCA_IS_VALID);
    433            RFST = SSTOP;
    434          
    435            /* per slotted CSMA-CCA in specification, wait one backoff */
    436            RFST = WAITW(1);
    437          
    438            /* sample CCA again, if it fails exit from here, CSPZ indicates result */
    439            RFST = SKIP(1, C_CCA_IS_VALID);
    440            RFST = SSTOP;
    441          
    442            /* CSMA has passed so transmit */
    443            RFST = STXON;
    444          
    445            /*
    446             *  Wait for the start of frame delimiter of the transmitted frame.  If SFD happens to
    447             *  already be active when STXON is strobed, it gets forced low.  How long this takes
    448             *  though, is not certain.  For bulletproof operation, the first step is to wait
    449             *  until SFD is inactive (which should be very fast if even necessary), and then wait
    450             *  for it to go active.
    451             */
    452            RFST = WHILE(C_SFD_IS_ACTIVE);
    453            RFST = WHILE(C_SFD_IS_INACTIVE);
    454          
    455            /*
    456             *  Record the timestamp.  The INT instruction causes an interrupt to fire.
    457             *  The ISR for this interrupt records the timestamp (which was just captured
    458             *  when SFD went high).
    459             */
    460            RFST = INT;
    461          
    462            /*
    463             *  Wait for SFD to go inactive which is the end of transmit.  Decrement CSPZ to indicate
    464             *  the transmit was successful.
    465             */
    466            RFST = WHILE(C_SFD_IS_ACTIVE);
    467            RFST = DECZ;
    468          
    469            /*
    470             * CC2530 requires SSTOP to generate CSP_STOP interrupt.
    471             */
    472            RFST = SSTOP;
    473          }
    474          
    475          
    476          /**************************************************************************************************
    477           * @fn          macCspTxGoCsma
    478           *
    479           * @brief       Run previously loaded CSP program for CSMA transmit.  Handles either
    480           *              slotted or unslotted CSMA transmits.  When CSP program has finished,
    481           *              an interrupt occurs and macCspTxStopIsr() is called.  This ISR will in
    482           *              turn call macTxDoneCallback().
    483           *
    484           * @param       none
    485           *
    486           * @return      none
    487           **************************************************************************************************
    488           */
    489          MAC_INTERNAL_API void macCspTxGoCsma(void)
    490          {
    491            /*
    492             *  Set CSPX with the countdown time of the CSMA delay.  
    493             */
    494            CSPX = macTxCsmaBackoffDelay;
    495          
    496            /*
    497             *  Set WEVENT to trigger at the current value of the timer.  This allows
    498             *  unslotted CSMA to transmit just a little bit sooner.
    499             */
    500            CSP_WEVENT_SET_TRIGGER_NOW();
    501          
    502            /*
    503             *  Enable interrupt that fires when CSP program stops.
    504             *  Also enable interrupt that fires when INT instruction
    505             *  is executed.
    506             */
    507            MAC_MCU_CSP_STOP_ENABLE_INTERRUPT();
    508            MAC_MCU_CSP_INT_ENABLE_INTERRUPT();
    509          
    510            /*
    511             *  Turn on the receiver if it is not already on.  Receiver must be 'on' for at
    512             *  least one backoff before performing clear channel assessment (CCA).
    513             */
    514            macRxOn();
    515          
    516            /* start the CSP program */
    517            CSP_START_PROGRAM();
    518          }
    519          
    520          
    521          /**************************************************************************************************
    522           * @fn          macCspTxPrepSlotted
    523           *
    524           * @brief       Prepare CSP for "Slotted" (non-CSMA) transmit.
    525           *              Load CSP program and set CSP parameters.
    526           *
    527           * @param       none
    528           *
    529           * @return      none
    530           **************************************************************************************************
    531           */
    532          MAC_INTERNAL_API void macCspTxPrepSlotted(void)
    533          {
    534            cspPrepForTxProgram();
    535          
    536            /*----------------------------------------------------------------------
    537             *  Load CSP program :  Slotted transmit (no CSMA)
    538             */
    539          
    540            /* wait for X number of backoffs */
    541            RFST = WAITX;
    542          
    543            /* just transmit, no CSMA required */
    544            RFST = STXON;
    545          
    546            /*
    547             *  Wait for the start of frame delimiter of the transmitted frame.  If SFD happens to
    548             *  already be active when STXON is strobed, it gets forced low.  How long this takes
    549             *  though, is not certain.  For bulletproof operation, the first step is to wait
    550             *  until SFD is inactive (which should be very fast if even necessary), and then wait
    551             *  for it to go active.
    552             */
    553            RFST = WHILE(C_SFD_IS_ACTIVE);
    554            RFST = WHILE(C_SFD_IS_INACTIVE);
    555          
    556            /*
    557             *  Record the timestamp.  The INT instruction causes an interrupt to fire.
    558             *  The ISR for this interrupt records the timestamp (which was just captured
    559             *  when SFD went high).
    560             */
    561            RFST = INT;
    562          
    563            /*
    564             *  Wait for SFD to go inactive which is the end of transmit.  Decrement CSPZ to indicate
    565             *  the transmit was successful.
    566             */
    567            RFST = WHILE(C_SFD_IS_ACTIVE);
    568            RFST = DECZ;
    569          
    570            /*
    571             * CC2530 requires SSTOP to generate CSP_STOP interrupt.
    572             */
    573            RFST = SSTOP;
    574          
    575          }
    576          
    577          
    578          /**************************************************************************************************
    579           * @fn          macCspTxGoSlotted
    580           *
    581           * @brief       Run previously loaded CSP program for non-CSMA slotted transmit.   When CSP
    582           *              program has finished, an interrupt occurs and macCspTxStopIsr() is called.
    583           *              This ISR will in turn call macTxDoneCallback().
    584           *
    585           * @param       none
    586           *
    587           * @return      none
    588           **************************************************************************************************
    589           */
    590          MAC_INTERNAL_API void macCspTxGoSlotted(void)
    591          {
    592            halIntState_t  s;
    593            uint8 lowByteOfBackoffCount;
    594            uint8 backoffCountdown;
    595          
    596            /*
    597             *  Enable interrupt that fires when CSP program stops.
    598             *  Also enable interrupt that fires when INT instruction
    599             *  is executed.
    600             */
    601            MAC_MCU_CSP_STOP_ENABLE_INTERRUPT();
    602            MAC_MCU_CSP_INT_ENABLE_INTERRUPT();
    603          
    604            /* critical section needed for timer accesses */
    605            HAL_ENTER_CRITICAL_SECTION(s);
    606          
    607            /* store lowest byte of backoff count (same as lowest byte of overflow count) */
    608            MAC_MCU_T2_ACCESS_OVF_COUNT_VALUE();
    609          
    610            /* Latch T2MOVFx */
    611            T2M0;
    612            lowByteOfBackoffCount = T2MOVF0;
    613          
    614            /*
    615             *  Compute the number of backoffs until time to strobe transmit.  The strobe should
    616             *  occur one backoff before the SFD pin is expected to go high.  So, the forumla for the
    617             *  countdown value is to determine when the lower bits would rollover and become zero,
    618             *  and then subtract one.
    619             */
    620            backoffCountdown = SLOTTED_TX_MAX_BACKOFF_COUNTDOWN - (lowByteOfBackoffCount & SLOTTED_TX_BACKOFF_COUNT_ALIGN_BIT_MASK) - 1;
    621          
    622            /*
    623             *  Store backoff countdown value into CSPX.
    624             *
    625             *  Note: it is OK if this value is zero.  The WAITX instruction at the top of the
    626             *  CSP program will immediately continue if CSPX is zero when executed.  However,
    627             *  if the countdown is zero, it means the transmit function was not called early
    628             *  enough for a properly timed slotted transmit.  The transmit will be late.
    629             */
    630            CSPX = backoffCountdown;
    631          
    632            /* Disable Rx and flush RXFIFO due to chip bug #1546 */
    633            macRxHardDisable();
    634          
    635            /*
    636             *  The receiver will be turned on during CSP execution, guaranteed.
    637             *  Since it is not possible to update C variables within the CSP,
    638             *  the new "on" state of the receiver must be set a little early
    639             *  here before the CSP is started.
    640             */
    641            MAC_RX_WAS_FORCED_ON();
    642          
    643            /* start the CSP program */
    644            CSP_START_PROGRAM();
    645          
    646            /*
    647             *  If the previous stored low byte of the backoff count is no longer equal to
    648             *  the current value, a rollover has occurred.  This means the backoff countdown
    649             *  stored in CSPX may not be correct.
    650             *
    651             *  In this case, the value of CSPX is reloaded to reflect the correct backoff
    652             *  countdown value (this is one less than what was just used as a rollover has
    653             *  occurred).  Since it is certain a rollover *just* occurred, there is no danger
    654             *  of another rollover occurring.  This means the value written to CSPX is guaranteed
    655             *  to be accurate.
    656             *
    657             *  Also, the logic below ensures that the value written to CSPX is at least one.
    658             *  This is needed for correct operation of the WAITX instruction.  As with an
    659             *  initial backoff countdown value of zero, if this case does occur, it means the
    660             *  transmit function was not called early enough for a properly timed slotted transmit.
    661             *  The transmit will be late.
    662             *
    663             *  Finally, worth noting, writes to CSPX may not work if the CSP is executing the WAITX
    664             *  instruction and a timer rollover occurs.  In this case, however, there is no possibility
    665             *  of that happening.  If CSPX is updated here, a rollover has just occurred so a
    666             *  collision is not possible (still within a critical section here too).
    667             */
    668            MAC_MCU_T2_ACCESS_OVF_COUNT_VALUE();
    669          
    670            /* Latch T2MOVFx */
    671            T2M0;
    672            if ((lowByteOfBackoffCount != T2MOVF0) && (backoffCountdown > 1))
    673            {
    674              CSPX = backoffCountdown - 1;
    675            }
    676          
    677            HAL_EXIT_CRITICAL_SECTION(s);
    678          }
    679          
    680          
    681          /**************************************************************************************************
    682           * @fn          macCspForceTxDoneIfPending
    683           *
    684           * @brief       The function clears out any pending TX done logic.  Used by receive logic
    685           *              to make sure its ISR does not prevent transmit from completing in a reasonable
    686           *              amount of time.
    687           *
    688           * @param       none
    689           *
    690           * @return      none
    691           **************************************************************************************************
    692           */
    693          MAC_INTERNAL_API void macCspForceTxDoneIfPending(void)
    694          {
    695            if ((CSPZ == CSPZ_CODE_TX_DONE) &&  MAC_MCU_CSP_STOP_INTERRUPT_IS_ENABLED())
    696            {
    697              MAC_MCU_CSP_STOP_DISABLE_INTERRUPT();
    698              if (MAC_MCU_CSP_INT_INTERRUPT_IS_ENABLED())
    699              {
    700                macCspTxIntIsr();
    701              }
    702              macTxDoneCallback();
    703            }
    704          }
    705          
    706          
    707          /**************************************************************************************************
    708           * @fn          macCspTxRequestAckTimeoutCallback
    709           *
    710           * @brief       Requests a callback after the ACK timeout period has expired.  At that point,
    711           *              the function macCspTxStopIsr() is called via an interrupt.
    712           *
    713           * @param       none
    714           *
    715           * @return      none
    716           **************************************************************************************************
    717           */
    718          MAC_INTERNAL_API void macCspTxRequestAckTimeoutCallback(void)
    719          {
    720            uint8 startSymbol;
    721            uint8 symbols;
    722            uint8 rollovers;
    723          
    724            MAC_ASSERT(!(RFIRQM1 & IM_CSP_STOP)); /* already an active CSP program */
    725          
    726            /* record current symbol count */
    727            startSymbol = CSP_WEVENT_READ_COUNT_SYMBOLS();
    728          
    729            /* set symbol timeout from PIB */
    730            symbols = macPib.ackWaitDuration;
    731          
    732            /* make sure delay value is not too small for logic to handle */
    733            MAC_ASSERT(symbols > MAC_A_UNIT_BACKOFF_PERIOD);  /* symbols timeout period must be great than a backoff */
    734          
    735            /* subtract out symbols left in current backoff period */
    736            symbols = symbols - (MAC_A_UNIT_BACKOFF_PERIOD - startSymbol);
    737          
    738            /* calculate rollovers needed for remaining symbols */
    739            rollovers = symbols / MAC_A_UNIT_BACKOFF_PERIOD;
    740          
    741            /* calculate symbols that still need counted after last rollover */
    742            symbols = symbols - (rollovers * MAC_A_UNIT_BACKOFF_PERIOD);
    743          
    744            /* add one to rollovers to account for symbols remaining in the current backoff period */
    745            rollovers++;
    746          
    747            /* set up parameters for CSP program */
    748            CSPZ = CSPZ_CODE_TX_ACK_TIME_OUT;
    749            CSPX = rollovers;
    750            CSP_WEVENT_SET_TRIGGER_SYMBOLS(symbols);
    751          
    752            /* clear the currently loaded CSP, this generates a stop interrupt which must be cleared */
    753            CSP_STOP_AND_CLEAR_PROGRAM();
    754            MAC_MCU_CSP_STOP_CLEAR_INTERRUPT();
    755          
    756            /*--------------------------
    757             * load CSP program
    758             */
    759            RFST = WAITX;
    760            RFST = WEVENT1;
    761            RFST = SSTOP;
    762          
    763            /*--------------------------
    764             */
    765          
    766            /* run CSP program */
    767            MAC_MCU_CSP_STOP_ENABLE_INTERRUPT();
    768            CSP_START_PROGRAM();
    769          
    770            /*
    771             *  For bullet proof operation, must account for the boundary condition
    772             *  where a rollover occurs after count was read but before CSP program
    773             *  was started.
    774             *
    775             *  If current symbol count is less that the symbol count recorded at the
    776             *  start of this function, a rollover has occurred.
    777             */
    778            if (CSP_WEVENT_READ_COUNT_SYMBOLS() < startSymbol)
    779            {
    780              /* a rollover has occurred, make sure it was accounted for */
    781              if (CSPX == rollovers)
    782              {
    783                /*
    784                 *  Rollover event missed, manually decrement CSPX to adjust.
    785                 *
    786                 *  Note : there is a very small chance that CSPX does not
    787                 *  get decremented.  This would occur if CSPX were written
    788                 *  at exactly the same time a timer overflow is occurring (which
    789                 *  causes the CSP instruction WAITX to decrement CSPX).  This
    790                 *  would be extremely rare, but if it does happen, the only
    791                 *  consequence is that the ACK timeout period is extended
    792                 *  by one backoff.
    793                 */
    794                CSPX--;
    795              }
    796            }
    797          }
    798          
    799          
    800          /**************************************************************************************************
    801           * @fn          macCspTxCancelAckTimeoutCallback
    802           *
    803           * @brief       Cancels previous request for ACK timeout callback.
    804           *
    805           * @param       none
    806           *
    807           * @return      none
    808           **************************************************************************************************
    809           */
    810          MAC_INTERNAL_API void macCspTxCancelAckTimeoutCallback(void)
    811          {
    812            MAC_MCU_CSP_STOP_DISABLE_INTERRUPT();
    813            CSP_STOP_AND_CLEAR_PROGRAM();
    814          }
    815          
    816          
    817          /**************************************************************************************************
    818           * @fn          macCspTxIntIsr
    819           *
    820           * @brief       Interrupt service routine for handling INT type interrupts from CSP.
    821           *              This interrupt happens when the CSP instruction INT is executed.  It occurs
    822           *              once the SFD signal goes high indicating that transmit has successfully
    823           *              started.  The timer value has been captured at this point and timestamp
    824           *              can be stored.
    825           *
    826           * @param       none
    827           *
    828           * @return      none
    829           **************************************************************************************************
    830           */
    831          MAC_INTERNAL_API void macCspTxIntIsr(void)
    832          {
    833            MAC_MCU_CSP_INT_DISABLE_INTERRUPT();
    834          
    835            /* execute callback function that records transmit timestamp */
    836            macTxTimestampCallback();
    837          }
    838          
    839          
    840          /**************************************************************************************************
    841           * @fn          macCspTxStopIsr
    842           *
    843           * @brief       Interrupt service routine for handling STOP type interrupts from CSP.
    844           *              This interrupt occurs when the CSP program stops by 1) reaching the end of the
    845           *              program, 2) executing SSTOP within the program, 3) executing immediate
    846           *              instruction ISSTOP.
    847           *
    848           *              The value of CSPZ indicates if interrupt is being used for ACK timeout or
    849           *              is the end of a transmit.
    850           *
    851           * @param       none
    852           *
    853           * @return      none
    854           **************************************************************************************************
    855           */
    856          MAC_INTERNAL_API void macCspTxStopIsr(void)
    857          {
    858            MAC_MCU_CSP_STOP_DISABLE_INTERRUPT();
    859          
    860            if (CSPZ == CSPZ_CODE_TX_DONE)
    861            {
    862              macTxDoneCallback();
    863            }
    864            else if (CSPZ == CSPZ_CODE_CHANNEL_BUSY)
    865            {
    866              macTxChannelBusyCallback();
    867            }
    868            else
    869            {
    870              MAC_ASSERT(CSPZ == CSPZ_CODE_TX_ACK_TIME_OUT); /* unexpected CSPZ value */
    871              macTxAckNotReceivedCallback();
    872            }
    873          }
    874          
    875          
    876          
    877          /**************************************************************************************************
    878           *                                  Compile Time Integrity Checks
    879           **************************************************************************************************
    880           */
    881          
    882          #if ((CSPZ_CODE_TX_DONE != 0) || (CSPZ_CODE_CHANNEL_BUSY != 1))
    883          #error "ERROR!  The CSPZ return values are very specific and tied into the actual CSP program."
    884          #endif
    885          
    886          #if (MAC_TX_TYPE_SLOTTED_CSMA != 0)
    887          #error "WARNING!  This define value changed.  It was selected for optimum performance."
    888          #endif
    889          
    890          #if (T2THD_TICKS_PER_SYMBOL == 0)
    891          #error "ERROR!  Timer compare will not work on high byte.  Clock speed is probably too slow."
    892          #endif
    893          
    894          #define BACKOFFS_PER_BASE_SUPERFRAME  (MAC_A_BASE_SLOT_DURATION * MAC_A_NUM_SUPERFRAME_SLOTS)
    895          #if (((BACKOFFS_PER_BASE_SUPERFRAME - 1) & SLOTTED_TX_BACKOFF_COUNT_ALIGN_BIT_MASK) != SLOTTED_TX_BACKOFF_COUNT_ALIGN_BIT_MASK)
    896          #error "ERROR!  The specified bit mask for backoff alignment of slotted transmit does not rollover 'cleanly'."
    897          /*
    898           *  In other words, the backoff count for the number of superframe rolls over before the
    899           *  specified number of bits rollover.  For example, if backoff count for a superframe
    900           *  rolls over at 48, the binary number immediately before a rollover is 00101111.
    901           *  In this case four bits would work as an alignment mask.  Five would not work though as
    902           *  the lower five bits would go from 01111 to 00000 (instead of the value 10000 which
    903           *  would be expected) because it a new superframe is starting.
    904           */
    905          #endif
    906          #if (SLOTTED_TX_MAX_BACKOFF_COUNTDOWN_NUM_BITS < 2)
    907          #error "ERROR!  Not enough backoff countdown bits to be practical."
    908          #endif
    909          
    910          
    911          /**************************************************************************************************
    912          */

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     cspPrepForTxProgram                2      0      0
       -> halAssertHandler              4      0      0
     cspReadCountSymbols                2      0      9
     cspWeventSetTriggerNow             2      0      0
     cspWeventSetTriggerSymbols         0      0     19
       -> halAssertHandler              0      0     20
     macCspForceTxDoneIfPending         2      0      0
       -> macCspTxIntIsr                4      0      0
       -> macTxDoneCallback             4      0      0
     macCspTxCancelAckTimeoutCallback
                                        2      0      0
     macCspTxGoCsma                     2      0      0
       -> cspWeventSetTriggerNow        4      0      0
       -> macRxOn                       4      0      0
     macCspTxGoSlotted                  0      0      9
       -> macRxHardDisable              0      0     18
     macCspTxIntIsr                     2      0      0
       -> macTxTimestampCallback        4      0      0
     macCspTxPrepCsmaSlotted            2      0      0
       -> cspPrepForTxProgram           4      0      0
     macCspTxPrepCsmaUnslotted          2      0      0
       -> cspPrepForTxProgram           4      0      0
     macCspTxPrepSlotted                2      0      0
       -> cspPrepForTxProgram           4      0      0
     macCspTxRequestAckTimeoutCallback
                                        0      0      9
       -> halAssertHandler              0      0     18
       -> cspReadCountSymbols           0      0     18
       -> halAssertHandler              0      0     18
       -> cspWeventSetTriggerSymbols
                                        0      0     18
       -> cspReadCountSymbols           0      0     18
     macCspTxReset                      2      0      0
     macCspTxStopIsr                    2      0      0
       -> macTxDoneCallback             4      0      0
       -> macTxChannelBusyCallback      4      0      0
       -> halAssertHandler              4      0      0
       -> macTxAckNotReceivedCallback
                                        4      0      0


   Segment part sizes:

     Function/Label                            Bytes
     --------------                            -----
     RFIRQF1                                      1
     S1CON                                        1
     T2CSPCFG                                     1
     T2IRQF                                       1
     T2M0                                         1
     T2M1                                         1
     T2MOVF0                                      1
     _A_IEN0                                      1
     T2MSEL                                       1
     RFST                                         1
     macCspTxReset                               14
     ?Subroutine2                                10
     ??Subroutine5_0                              7
     cspWeventSetTriggerNow                      51
     ?Subroutine3                                 5
     cspWeventSetTriggerSymbols                  78
     cspReadCountSymbols                         40
     cspPrepForTxProgram                         59
     ?Subroutine0                                 6
     ??Subroutine4_0                             21
     macCspTxPrepCsmaUnslotted                   18
     macCspTxPrepCsmaSlotted                     27
     macCspTxGoCsma                              34
     macCspTxPrepSlotted                         12
     macCspTxGoSlotted                           88
     ?Subroutine1                                 5
     macCspForceTxDoneIfPending                  36
     macCspTxRequestAckTimeoutCallback
                                                131
     macCspTxCancelAckTimeoutCallback
                                                 13
     macCspTxIntIsr                              17
     macCspTxStopIsr                             46
     ??macCspTxReset?relay                        6
     ??cspWeventSetTriggerNow?relay               6
     ??cspWeventSetTriggerSymbols?relay           6
     ??cspReadCountSymbols?relay                  6
     ??cspPrepForTxProgram?relay                  6
     ??macCspTxPrepCsmaUnslotted?relay            6
     ??macCspTxPrepCsmaSlotted?relay              6
     ??macCspTxGoCsma?relay                       6
     ??macCspTxPrepSlotted?relay                  6
     ??macCspTxGoSlotted?relay                    6
     ??macCspForceTxDoneIfPending?relay           6
     ??macCspTxRequestAckTimeoutCallback?relay    6
     ??macCspTxCancelAckTimeoutCallback?relay     6
     ??macCspTxIntIsr?relay                       6
     ??macCspTxStopIsr?relay                      6

 
 718 bytes in segment BANKED_CODE
  90 bytes in segment BANK_RELAYS
  10 bytes in segment SFR_AN
 
 808 bytes of CODE memory
   0 bytes of DATA memory (+ 10 bytes shared)

Errors: none
Warnings: none
