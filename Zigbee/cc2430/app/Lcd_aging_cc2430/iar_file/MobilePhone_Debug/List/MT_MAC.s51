///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR 8051 C/C++ Compiler V7.30B/W32                   11/Oct/2011  15:26:31 /
// Copyright 2004-2007 IAR Systems. All rights reserved.                      /
//                                                                            /
//    Core               =  plain                                             /
//    Code model         =  banked                                            /
//    Data model         =  large                                             /
//    Calling convention =  xdata reentrant                                   /
//    Constant location  =  data                                              /
//    Dptr setup         =  1,16                                              /
//    Source file        =  E:\work_wangti\main\Zigbee\cc2430\third_party\Zst /
//                          ack\Components\mt\MT_MAC.c                        /
//    Command line       =  -f E:\work_wangti\main\Zigbee\cc2430\app\Lcd_agin /
//                          g_cc2430\iar_file\..\config\f8wEndev.cfg          /
//                          (-DCPU32MHZ -DFORCE_MAC_NEAR -DROOT=__near_func   /
//                          -DMAC_OPT_FFD=0 -DBLINK_LEDS "-DCONST=const       /
//                          __code" -DGENERIC=__generic                       /
//                          -DOSC32K_CRYSTAL_INSTALLED=FALSE) -f              /
//                          E:\work_wangti\main\Zigbee\cc2430\app\Lcd_aging_c /
//                          c2430\iar_file\..\config\f8wConfig.cfg            /
//                          (-DSECURE=0 -DDEFAULT_CHANLIST=0x00000800         /
//                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                      /
//                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_M /
//                          ASK=0x007F -DBEACON_REQUEST_DELAY=100             /
//                          -DBEACON_REQ_DELAY_MASK=0x00FF                    /
//                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_P /
//                          OLLED=500 -DNWK_INDIRECT_MSG_TIMEOUT=7            /
//                          -DMAX_RREQ_ENTRIES=10 -DAPSC_MAX_FRAME_RETRIES=3  /
//                          -DNWK_MAX_DATA_RETRIES=2                          /
//                          -DMAX_POLL_FAILURE_RETRIES=10 -DMAX_BCAST=9       /
//                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=20          /
//                          -DNWK_MAX_BINDING_ENTRIES=10                      /
//                          -DMAX_BINDING_CLUSTER_IDS=5                       /
//                          "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07, 0x09,     /
//                          0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08,   /
//                          0x0A, 0x0C, 0x0D}" -DRFD_RCVC_ALWAYS_ON=TRUE      /
//                          -DPOLL_RATE=220 -DQUEUED_POLL_RATE=20             /
//                          -DRESPONSE_POLL_RATE=20 -DREJOIN_POLL_RATE=440    /
//                          -DOSAL_NV_PAGES_USED=4) -DOSAL_NV_PAGE_BEG=58     /
//                          E:\work_wangti\main\Zigbee\cc2430\third_party\Zst /
//                          ack\Components\mt\MT_MAC.c -D MENU_RF_DEBUG -D    /
//                          RSSI_INFORMATION -D PACKAGE_INFORMATION -D        /
//                          xSMS_TEMPLATE -D xMENU_CLOCKFORMAT -D             /
//                          CELLSWITCH_DEBUG -D MP_INFORMATION -D             /
//                          HOLD_AUTO_START -D xSMS_SENDBOX -D                /
//                          xMP_VERSION_1_1 -D NEW_MENU_LIB -D WATCHDOG=TRUE  /
//                          -D NEW_DOUBLE_NVID_OP -D AUDIO_SERIAL -D          /
//                          MINE_PROJECTS -D NWK_AUTO_POLL -D xAUDIO_TEST -D  /
//                          xSINGLE_AUDIO_TEST -D xMULTIAUDIO_TEST -D         /
//                          xREFLECTOR -D xLCD_SUPPORTED -D HAL_LCD=FALSE -D  /
//                          HAL_AUDIO=TRUE -D HAL_SPI=FALSE -D                /
//                          HAL_UART=FALSE -D HAL_LED=FALSE -D HAL_AES=FALSE  /
//                          -D HAL_DMA=FALSE -D IDX_THRESHOLD=12 -D           /
//                          MACNODEBUG -D MAC_NO_PARAM_CHECK -lC              /
//                          E:\work_wangti\main\Zigbee\cc2430\app\Lcd_aging_c /
//                          c2430\iar_file\MobilePhone_Debug\List\ -lA        /
//                          E:\work_wangti\main\Zigbee\cc2430\app\Lcd_aging_c /
//                          c2430\iar_file\MobilePhone_Debug\List\            /
//                          --diag_suppress Pe001,Pa010 --diag_remark pe550   /
//                          -o E:\work_wangti\main\Zigbee\cc2430\app\Lcd_agin /
//                          g_cc2430\iar_file\MobilePhone_Debug\Obj\ -e       /
//                          --require_prototypes -z9 --debug --core=plain     /
//                          --dptr=16,1 --data_model=large                    /
//                          --code_model=banked --calling_convention=xdata_re /
//                          entrant --place_constants=data --nr_virtual_regs  /
//                          8 -I E:\work_wangti\main\Zigbee\cc2430\app\Lcd_ag /
//                          ing_cc2430\iar_file\ -I                           /
//                          E:\work_wangti\main\Zigbee\cc2430\app\Lcd_aging_c /
//                          c2430\iar_file\..\..\..\util\ -I                  /
//                          E:\work_wangti\main\Zigbee\cc2430\app\Lcd_aging_c /
//                          c2430\iar_file\..\..\..\..\..\common\ -I          /
//                          E:\work_wangti\main\Zigbee\cc2430\app\Lcd_aging_c /
//                          c2430\iar_file\..\..\..\..\..\common\1g\ -I       /
//                          E:\work_wangti\main\Zigbee\cc2430\app\Lcd_aging_c /
//                          c2430\iar_file\..\..\..\..\..\ -I                 /
//                          E:\work_wangti\main\Zigbee\cc2430\app\Lcd_aging_c /
//                          c2430\iar_file\..\..\..\..\..\..\ALGORITHM\lib\Lo /
//                          cationEngine\cc2431\ -I                           /
//                          E:\work_wangti\main\Zigbee\cc2430\app\Lcd_aging_c /
//                          c2430\iar_file\..\SOURCE\ -I                      /
//                          E:\work_wangti\main\Zigbee\cc2430\app\Lcd_aging_c /
//                          c2430\iar_file\..\SOURCE\Location\ -I             /
//                          E:\work_wangti\main\Zigbee\cc2430\app\Lcd_aging_c /
//                          c2430\iar_file\..\SOURCE\MenuLib\ -I              /
//                          E:\work_wangti\main\Zigbee\cc2430\app\Lcd_aging_c /
//                          c2430\iar_file\..\SOURCE\MenuLib\Util\ -I         /
//                          E:\work_wangti\main\Zigbee\cc2430\app\Lcd_aging_c /
//                          c2430\iar_file\..\..\..\third_party\Zstack\Projec /
//                          ts\zstack\ZMAIN\TI2430DB\ -I                      /
//                          E:\work_wangti\main\Zigbee\cc2430\app\Lcd_aging_c /
//                          c2430\iar_file\..\..\..\third_party\Zstack\COMPON /
//                          ENTS\MT\ -I E:\work_wangti\main\Zigbee\cc2430\app /
//                          \Lcd_aging_cc2430\iar_file\..\..\..\third_party\Z /
//                          stack\COMPONENTS\HAL\INCLUDE\ -I                  /
//                          E:\work_wangti\main\Zigbee\cc2430\app\Lcd_aging_c /
//                          c2430\iar_file\..\..\..\driver\ -I                /
//                          E:\work_wangti\main\Zigbee\cc2430\app\Lcd_aging_c /
//                          c2430\iar_file\..\..\..\driver\yiri_MP\ -I        /
//                          E:\work_wangti\main\Zigbee\cc2430\app\Lcd_aging_c /
//                          c2430\iar_file\..\..\..\driver\yiri_MP\audio\ -I  /
//                          E:\work_wangti\main\Zigbee\cc2430\app\Lcd_aging_c /
//                          c2430\iar_file\..\..\..\driver\yiri_MP\comm\ -I   /
//                          E:\work_wangti\main\Zigbee\cc2430\app\Lcd_aging_c /
//                          c2430\iar_file\..\..\..\driver\yiri_MP\key\ -I    /
//                          E:\work_wangti\main\Zigbee\cc2430\app\Lcd_aging_c /
//                          c2430\iar_file\..\..\..\driver\yiri_MP\lcd\ -I    /
//                          E:\work_wangti\main\Zigbee\cc2430\app\Lcd_aging_c /
//                          c2430\iar_file\..\..\..\third_party\Zstack\COMPON /
//                          ENTS\OSAL\MCU\CCSOC\ -I                           /
//                          E:\work_wangti\main\Zigbee\cc2430\app\Lcd_aging_c /
//                          c2430\iar_file\..\..\..\third_party\Zstack\COMPON /
//                          ENTS\OSAL\INCLUDE\ -I E:\work_wangti\main\Zigbee\ /
//                          cc2430\app\Lcd_aging_cc2430\iar_file\..\..\..\thi /
//                          rd_party\Zstack\COMPONENTS\STACK\AF\ -I           /
//                          E:\work_wangti\main\Zigbee\cc2430\app\Lcd_aging_c /
//                          c2430\iar_file\..\..\..\third_party\Zstack\COMPON /
//                          ENTS\STACK\NWK\ -I E:\work_wangti\main\Zigbee\cc2 /
//                          430\app\Lcd_aging_cc2430\iar_file\..\..\..\third_ /
//                          party\Zstack\COMPONENTS\STACK\SEC\ -I             /
//                          E:\work_wangti\main\Zigbee\cc2430\app\Lcd_aging_c /
//                          c2430\iar_file\..\..\..\third_party\Zstack\COMPON /
//                          ENTS\STACK\SYS\ -I E:\work_wangti\main\Zigbee\cc2 /
//                          430\app\Lcd_aging_cc2430\iar_file\..\..\..\third_ /
//                          party\Zstack\COMPONENTS\STACK\ZDO\ -I             /
//                          E:\work_wangti\main\Zigbee\cc2430\app\Lcd_aging_c /
//                          c2430\iar_file\..\..\..\third_party\Zstack\COMPON /
//                          ENTS\ZMAC\F8W\ -I E:\work_wangti\main\Zigbee\cc24 /
//                          30\app\Lcd_aging_cc2430\iar_file\..\..\..\third_p /
//                          arty\Zstack\COMPONENTS\ZMAC\ -I                   /
//                          E:\work_wangti\main\Zigbee\cc2430\app\Lcd_aging_c /
//                          c2430\iar_file\..\..\..\third_party\Zstack\COMPON /
//                          ENTS\SERVICES\SADDR\ -I                           /
//                          E:\work_wangti\main\Zigbee\cc2430\app\Lcd_aging_c /
//                          c2430\iar_file\..\..\..\third_party\Zstack\COMPON /
//                          ENTS\SERVICES\SDATA\ -I                           /
//                          E:\work_wangti\main\Zigbee\cc2430\app\Lcd_aging_c /
//                          c2430\iar_file\..\..\..\third_party\Zstack\COMPON /
//                          ENTS\MAC\INCLUDE\ -I E:\work_wangti\main\Zigbee\c /
//                          c2430\app\Lcd_aging_cc2430\iar_file\..\..\..\thir /
//                          d_party\Zstack\COMPONENTS\MAC\HIGH_LEVEL\ -I      /
//                          E:\work_wangti\main\Zigbee\cc2430\app\Lcd_aging_c /
//                          c2430\iar_file\..\..\..\third_party\Zstack\COMPON /
//                          ENTS\MAC\LOW_LEVEL\SRF03\ -I                      /
//                          E:\work_wangti\main\Zigbee\cc2430\app\Lcd_aging_c /
//                          c2430\iar_file\..\..\..\third_party\Zstack\COMPON /
//                          ENTS\MAC\LOW_LEVEL\SRF03\SINGLE_CHIP\ -I          /
//                          "C:\Program Files\IAR Systems\Embedded Workbench  /
//                          4.0 Evaluation version\8051\INC\" -I "C:\Program  /
//                          Files\IAR Systems\Embedded Workbench 4.0          /
//                          Evaluation version\8051\INC\CLIB\"                /
//    List file          =  E:\work_wangti\main\Zigbee\cc2430\app\Lcd_aging_c /
//                          c2430\iar_file\MobilePhone_Debug\List\MT_MAC.s51  /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME MT_MAC

        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)


        END
// E:\work_wangti\main\Zigbee\cc2430\third_party\Zstack\Components\mt\MT_MAC.c
//    1 /**************************************************************************************************
//    2   Filename:       MT_MAC.c
//    3   Revised:        $Date: 2009/02/07 01:08:32 $
//    4   Revision:       $Revision: 1.1.1.1 $
//    5 
//    6   Description:    MonitorTest functions for the MAC layer.
//    7 
//    8 
//    9   Copyright 2004-2007 Texas Instruments Incorporated. All rights reserved.
//   10 
//   11   IMPORTANT: Your use of this Software is limited to those specific rights
//   12   granted under the terms of a software license agreement between the user
//   13   who downloaded the software, his/her employer (which must be your employer)
//   14   and Texas Instruments Incorporated (the "License").  You may not use this
//   15   Software unless you agree to abide by the terms of the License. The License
//   16   limits your use, and you acknowledge, that the Software may not be modified,
//   17   copied or distributed unless embedded on a Texas Instruments microcontroller
//   18   or used solely and exclusively in conjunction with a Texas Instruments radio
//   19   frequency transceiver, which is integrated into your product.  Other than for
//   20   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   21   works of, modify, distribute, perform, display or sell this Software and/or
//   22   its documentation for any purpose.
//   23 
//   24   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   25   PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
//   26   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, 
//   27   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   28   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   29   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   30   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   31   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   32   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   33   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   34   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   35 
//   36   Should you have any questions regarding your right to use this Software,
//   37   contact Texas Instruments Incorporated at www.TI.com. 
//   38 **************************************************************************************************/
//   39 
//   40 #if defined ( MT_MAC_FUNC )             //MAC commands
//   41 /*********************************************************************
//   42  * INCLUDES
//   43  */
//   44 #include "ZComDef.h"
//   45 #include "OSAL.h"
//   46 #include "MTEL.h"
//   47 #include "ZMAC.h"
//   48 #include "MT_MAC.h"
//   49 
//   50 #if !defined( WIN32 )
//   51   #include "OnBoard.h"
//   52 #endif
//   53 
//   54 /* Hal */
//   55 #include "hal_uart.h"
//   56 #include "SPIMgr.h"
//   57 
//   58 /*********************************************************************
//   59  * MACROS
//   60  */
//   61 
//   62 /* The length in bytes of the pending address fields in the beacon */
//   63 #define MT_MAC_PEND_LEN(pendAddrSpec)   ((((pendAddrSpec) & 0x07) * 2) + \ 
//   64                                         ((((pendAddrSpec) & 0x70) >> 4) * 8))
//   65 
//   66 /* This matches the value used by nwk */
//   67 #define MT_MAC_ED_SCAN_MAXCHANNELS      27
//   68 
//   69 /* Maximum size of pending address spec in beacon notify ind */
//   70 #define MT_MAC_PEND_LEN_MAX             32
//   71 
//   72 /* Maximum size of the payload SDU in beacon notify ind */
//   73 #define MT_MAC_SDU_LEN_MAX              32
//   74 
//   75 /* Maximum length of scan result in bytes */
//   76 #define MT_MAC_SCAN_RESULT_LEN_MAX      32
//   77 
//   78 /* Maximum size of beacon payload */
//   79 #define MT_MAC_BEACON_PAYLOAD_MAX       16
//   80 
//   81 /*********************************************************************
//   82  * CONSTANTS
//   83  */
//   84 #define DEFAULT_NSDU_HANDLE             0x00
//   85 
//   86 /*********************************************************************
//   87  * TYPEDEFS
//   88  */
//   89 
//   90 /*********************************************************************
//   91  * GLOBAL VARIABLES
//   92  */
//   93 uint16 _macCallbackSub;
//   94 
//   95 union
//   96 {
//   97   ZMacStartReq_t        startReq;
//   98   ZMacScanReq_t         scanReq;
//   99   ZMacDataReq_t         dataReq;
//  100   ZMacAssociateReq_t    assocReq;
//  101   ZMacAssociateRsp_t    assocRsp;
//  102   ZMacDisassociateReq_t disassocReq;
//  103   ZMacOrphanRsp_t       orphanRsp;
//  104   ZMacRxEnableReq_t     rxEnableReq;
//  105   ZMacSyncReq_t         syncReq;
//  106   ZMacPollReq_t         pollReq;
//  107 } mtMac;
//  108 
//  109 /*********************************************************************
//  110  * EXTERNAL VARIABLES
//  111  */
//  112 
//  113 /*********************************************************************
//  114  * EXTERNAL FUNCTIONS
//  115  */
//  116 
//  117 /*********************************************************************
//  118  * LOCAL VARIABLES
//  119  */
//  120 
//  121 /*********************************************************************
//  122  * LOCAL FUNCTIONS
//  123  */
//  124 
//  125 /* storage for MAC beacon payload */
//  126 static uint8 mtMacBeaconPayload[MT_MAC_BEACON_PAYLOAD_MAX];
//  127 
//  128 /*********************************************************************
//  129  * @fn      MT_MacRevExtCpy
//  130  *
//  131  * @brief
//  132  *
//  133  *   Reverse-copy an extended address.
//  134  *
//  135  * @param   pDst - Pointer to data destination
//  136  * @param   pSrc - Pointer to data source
//  137  *
//  138  * @return  void
//  139  */
//  140 static void MT_MacRevExtCpy( uint8 *pDst, uint8 *pSrc )
//  141 {
//  142   int8 i;
//  143 
//  144   for ( i = Z_EXTADDR_LEN - 1; i >= 0; i-- )
//  145   {
//  146     *pDst++ = pSrc[i];
//  147   }
//  148 }
//  149 
//  150 /*********************************************************************
//  151  * @fn      MT_MacSpi2Addr
//  152  *
//  153  * @brief
//  154  *
//  155  *   Copy an address from an SPI message to an address struct.  The
//  156  *   addrMode in pAddr must already be set.
//  157  *
//  158  * @param   pDst - Pointer to address struct
//  159  * @param   pSrc - Pointer SPI message byte array
//  160  *
//  161  * @return  void
//  162  *********************************************************************/
//  163 static void MT_MacSpi2Addr( zAddrType_t *pDst, uint8 *pSrc )
//  164 {
//  165   if ( pDst->addrMode == Addr16Bit )
//  166   {
//  167     pDst->addr.shortAddr = BUILD_UINT16( pSrc[7] , pSrc[6] );
//  168   }
//  169   else if ( pDst->addrMode == Addr64Bit )
//  170   {
//  171     MT_MacRevExtCpy( pDst->addr.extAddr, pSrc );
//  172   }
//  173 }
//  174 
//  175 /*********************************************************************
//  176  * @fn      MT_MacSpi2Sec
//  177  *
//  178  * @brief
//  179  *
//  180  *   Copy Security information from SPI message to a Sec structure
//  181  *
//  182  * @param   pSec - Pointer to security struct
//  183  * @param   pSrc - Pointer SPI message byte array
//  184  *
//  185  * @return  void
//  186  *********************************************************************/
//  187 static void MT_MacSpi2Sec( ZMacSec_t *pSec, uint8 *pSrc )
//  188 {
//  189   /* Right now, set everything to zero */
//  190   osal_memset (pSec, 0, sizeof (ZMacSec_t));
//  191 }
//  192 
//  193 /*********************************************************************
//  194  * @fn      MT_MacAddr2Spi
//  195  *
//  196  * @brief
//  197  *
//  198  *   Copy an address from an address struct to an SPI message.
//  199  *
//  200  * @param   pDst - Pointer SPI message byte array
//  201  * @param   pSrc - Pointer to address struct
//  202  *
//  203  * @return  void
//  204  *********************************************************************/
//  205 static void MT_MacAddr2Spi( uint8 *pDst, zAddrType_t *pSrc )
//  206 {
//  207   if ( pSrc->addrMode == Addr16Bit )
//  208   {
//  209     *pDst++ = 0; *pDst++ = 0; *pDst++ = 0;
//  210     *pDst++ = 0; *pDst++ = 0; *pDst++ = 0;
//  211     *pDst++ = HI_UINT16( pSrc->addr.shortAddr );
//  212     *pDst = LO_UINT16( pSrc->addr.shortAddr );
//  213   }
//  214   else if ( pSrc->addrMode == Addr64Bit )
//  215   {
//  216     MT_MacRevExtCpy( pDst, pSrc->addr.extAddr );
//  217   }
//  218 }
//  219 
//  220 
//  221 /*********************************************************************
//  222  * @fn      MT_MacMsgAllocate
//  223  *
//  224  * @brief
//  225  *
//  226  *   Allocate an MT MAC SPI message buffer.
//  227  *
//  228  * @param   cmd - SPI command id
//  229  * @param   len - length of SPI command parameters
//  230  *
//  231  * @return  pointer to allocated message
//  232  *********************************************************************/
//  233 static mtOSALSerialData_t *MT_MacMsgAllocate( uint16 cmd, uint8 len )
//  234 {
//  235   mtOSALSerialData_t  *msgPtr;
//  236   byte                *msg;
//  237 
//  238   msgPtr = (mtOSALSerialData_t *) osal_msg_allocate( len +
//  239                                                      sizeof(mtOSALSerialData_t) +
//  240                                                      SPI_0DATA_MSG_LEN );
//  241   if ( msgPtr )
//  242   {
//  243     msgPtr->hdr.event = CB_FUNC;
//  244     msg = msgPtr->msg = (uint8 *) ( msgPtr + 1 );
//  245     *msg++ = SOP_VALUE;
//  246     *msg++ = HI_UINT16( cmd );
//  247     *msg++ = LO_UINT16( cmd );
//  248     *msg   = len;
//  249   }
//  250   return msgPtr;
//  251 }
//  252 
//  253 /*********************************************************************
//  254  * @fn      MT_MacCommandProcessing
//  255  *
//  256  * @brief
//  257  *
//  258  *   Process all the MAC commands that are issued by test tool
//  259  *
//  260  * @param   cmd_id - Command ID
//  261  * @param   len    - Length of received SPI pData message
//  262  * @param   pData  - pointer to received SPI pData message
//  263  *
//  264  * @return  void
//  265  */
//  266 void MT_MacCommandProcessing( uint16 cmd_id , byte len , byte *pData )
//  267 {
//  268   byte *msg_ptr;
//  269   ZMacStatus_t ret;
//  270   byte attr;
//  271 
//  272   ret = ZMacSuccess;
//  273 
//  274   switch ( cmd_id )
//  275   {
//  276     case SPI_CMD_MAC_INIT:
//  277       ret = ZMacInit();
//  278 
//  279       len = SPI_0DATA_MSG_LEN + SPI_RESP_LEN_MAC_DEFAULT;
//  280       MT_SendSPIRespMsg( (byte)ret, SPI_CMD_MAC_INIT, len, SPI_RESP_LEN_MAC_DEFAULT);
//  281       break;
//  282 
//  283     case SPI_CMD_MAC_START_REQ:
//  284 #ifdef RTR_NWK
//  285 
//  286       /* StartTime */
//  287       mtMac.startReq.StartTime = BUILD_UINT32 (pData[3], pData[2], pData[1], pData[0]);
//  288       pData += 4;
//  289 
//  290       /* PanID */
//  291       mtMac.startReq.PANID = BUILD_UINT16( pData[1] , pData[0] );
//  292       pData += 2;
//  293 
//  294       /* Fill in other fields sequentially incrementing the pointer*/
//  295       mtMac.startReq.LogicalChannel    =  *pData++;
//  296       mtMac.startReq.ChannelPage       =  *pData++;
//  297       mtMac.startReq.BeaconOrder       =  *pData++;
//  298       mtMac.startReq.SuperframeOrder   =  *pData++;
//  299       mtMac.startReq.PANCoordinator    =  *pData++;
//  300       mtMac.startReq.BatteryLifeExt    =  *pData++;
//  301       mtMac.startReq.CoordRealignment  =  *pData++;
//  302 
//  303       /* Realign Security Information */
//  304       MT_MacSpi2Sec( &mtMac.startReq.RealignSec, pData );
//  305       pData += ZTEST_DEFAULT_SEC_LEN;
//  306 
//  307       /* Beacon Security Information */
//  308       MT_MacSpi2Sec( &mtMac.startReq.BeaconSec, pData );
//  309 
//  310       /* Call corresponding ZMAC function */
//  311       ret = ZMacStartReq( &mtMac.startReq );
//  312 #else
//  313       ret = ZMacDenied;
//  314 #endif
//  315 
//  316       len = SPI_0DATA_MSG_LEN + SPI_RESP_LEN_MAC_DEFAULT;
//  317       MT_SendSPIRespMsg( (byte)ret, SPI_CMD_MAC_START_REQ, len, SPI_RESP_LEN_MAC_DEFAULT);
//  318       break;
//  319 
//  320     case SPI_CMD_MAC_SCAN_REQ:
//  321 
//  322       /* ScanChannels is the 32-bit channel list */
//  323       mtMac.scanReq.ScanChannels = BUILD_UINT32 (pData[3], pData[2], pData[1], pData[0]);
//  324       pData += 4;
//  325 
//  326       /* Fill in fields sequentially incrementing the pointer */
//  327       mtMac.scanReq.ScanType = *pData++;
//  328 
//  329       /* ScanDuration */
//  330       mtMac.scanReq.ScanDuration = *pData++;
//  331 
//  332       /* Channel Page */
//  333       mtMac.scanReq.ChannelPage = *pData++;
//  334 
//  335       /* MaxResults */
//  336       mtMac.scanReq.MaxResults = *pData++;
//  337 
//  338       /* Security Information */
//  339       MT_MacSpi2Sec( &mtMac.scanReq.Sec, pData );
//  340 
//  341       /* Call corresponding ZMAC function */
//  342       ret =  ZMacScanReq( &mtMac.scanReq );
//  343 
//  344       len = SPI_0DATA_MSG_LEN + SPI_RESP_LEN_MAC_DEFAULT;
//  345       MT_SendSPIRespMsg( (byte)ret, SPI_CMD_MAC_SCAN_REQ, len, SPI_RESP_LEN_MAC_DEFAULT);
//  346 
//  347       break;
//  348 
//  349     case SPI_CMD_MAC_DATA_REQ:
//  350 
//  351       /* Destination address mode */
//  352       mtMac.dataReq.DstAddr.addrMode = *pData++;
//  353 
//  354       /* Destination address */
//  355       MT_MacSpi2Addr( &mtMac.dataReq.DstAddr, pData);
//  356       pData += Z_EXTADDR_LEN;
//  357 
//  358       /* Destination Pan ID */
//  359       mtMac.dataReq.DstPANId = BUILD_UINT16( pData[1] , pData[0] );
//  360       pData += 2;
//  361 
//  362       /* Source address mode */
//  363       mtMac.dataReq.SrcAddrMode = *pData++;
//  364 
//  365       /* Handle */
//  366       mtMac.dataReq.Handle = *pData++;
//  367 
//  368       /* TxOptions */
//  369       mtMac.dataReq.TxOptions = *pData++;
//  370 
//  371       /* Channel */
//  372       mtMac.dataReq.Channel = *pData++;
//  373 
//  374       /* Power */
//  375       mtMac.dataReq.Power = *pData++;
//  376 
//  377       /* Security Information */
//  378       MT_MacSpi2Sec( &mtMac.dataReq.Sec, pData );
//  379       pData += ZTEST_DEFAULT_SEC_LEN;
//  380 
//  381       /* Data length */
//  382       mtMac.dataReq.msduLength = *pData++;
//  383 
//  384       /* Data - Just pass the pointer to the structure */
//  385       mtMac.dataReq.msdu = pData;
//  386 
//  387       /* Call corresponding ZMAC function */
//  388       ret = ZMacDataReq( &mtMac.dataReq );
//  389 
//  390       /* Send response back */
//  391       len = SPI_0DATA_MSG_LEN + SPI_RESP_LEN_MAC_DEFAULT;
//  392       MT_SendSPIRespMsg( (byte)ret, SPI_CMD_MAC_DATA_REQ, len, SPI_RESP_LEN_MAC_DEFAULT);
//  393       break;
//  394 
//  395     case SPI_CMD_MAC_ASSOCIATE_REQ:
//  396 
//  397       /* Logical Channel */
//  398       mtMac.assocReq.LogicalChannel = *pData++;
//  399 
//  400       /* Channel Page */
//  401       mtMac.assocReq.ChannelPage = *pData++;
//  402 
//  403       /* Address Mode */
//  404       mtMac.assocReq.CoordAddress.addrMode = *pData++;
//  405 
//  406       /* Coordinator Address, address mode must be set at this point */
//  407       MT_MacSpi2Addr( &mtMac.assocReq.CoordAddress, pData );
//  408       pData += Z_EXTADDR_LEN;
//  409 
//  410       /* Coordinator PanID */
//  411       mtMac.assocReq.CoordPANId = BUILD_UINT16( pData[1] , pData[0] );
//  412       pData += 2;
//  413 
//  414       /* Capability information */
//  415       mtMac.assocReq.CapabilityInformation = *pData++;
//  416 
//  417       /* Security Information */
//  418       MT_MacSpi2Sec( &mtMac.assocReq.Sec, pData );
//  419 
//  420       /* Call corresponding ZMAC function */
//  421       ret = ZMacAssociateReq( &mtMac.assocReq );
//  422 
//  423       /* Send response back */
//  424       len = SPI_0DATA_MSG_LEN + SPI_RESP_LEN_MAC_DEFAULT;
//  425       MT_SendSPIRespMsg( (byte)ret, SPI_CMD_MAC_ASSOCIATE_REQ, len, SPI_RESP_LEN_MAC_DEFAULT);
//  426       break;
//  427 
//  428     case SPI_CMD_MAC_ASSOCIATE_RSP:
//  429 #ifdef RTR_NWK
//  430 
//  431       /* Device extended address */
//  432       MT_MacRevExtCpy( mtMac.assocRsp.DeviceAddress, pData );
//  433       pData += Z_EXTADDR_LEN;
//  434 
//  435       /* Associated short address */
//  436       mtMac.assocRsp.AssocShortAddress = BUILD_UINT16(pData[1],pData[0]);
//  437       pData += 2;
//  438 
//  439       /* Status */
//  440       mtMac.assocRsp.Status = *pData++;
//  441 
//  442       /* Security Information */
//  443       MT_MacSpi2Sec( &mtMac.assocRsp.Sec, pData );
//  444 
//  445       /* Call corresponding ZMAC function */
//  446       ret = ZMacAssociateRsp( &mtMac.assocRsp );
//  447 #else
//  448       ret = ZMacDenied;
//  449 #endif
//  450 
//  451       len = SPI_0DATA_MSG_LEN + SPI_RESP_LEN_MAC_DEFAULT;
//  452       MT_SendSPIRespMsg( (byte)ret, SPI_CMD_MAC_ASSOCIATE_RSP, len, SPI_RESP_LEN_MAC_DEFAULT);
//  453       break;
//  454 
//  455     case SPI_CMD_MAC_DISASSOCIATE_REQ:
//  456 
//  457       /* Device address mode */
//  458       mtMac.disassocReq.DeviceAddress.addrMode = *pData++;
//  459 
//  460       /* Device address - Device address mode have to be set to use this function*/
//  461       MT_MacSpi2Addr( &mtMac.disassocReq.DeviceAddress, pData);
//  462       pData += Z_EXTADDR_LEN;
//  463 
//  464       /* Pan ID */
//  465       mtMac.disassocReq.DevicePanId = BUILD_UINT16( pData[1] , pData[0] );
//  466       pData += 2;
//  467 
//  468       /* Disassociate reason */
//  469       mtMac.disassocReq.DisassociateReason = *pData++;
//  470 
//  471       /* TxIndirect */
//  472       mtMac.disassocReq.TxIndirect = *pData++;
//  473 
//  474       /* Security Information */
//  475       MT_MacSpi2Sec( &mtMac.disassocReq.Sec, pData );
//  476 
//  477       /* Call corresponding ZMAC function */
//  478       ret = ZMacDisassociateReq( &mtMac.disassocReq );
//  479 
//  480       len = SPI_0DATA_MSG_LEN + SPI_RESP_LEN_MAC_DEFAULT;
//  481       MT_SendSPIRespMsg( (byte)ret, SPI_CMD_MAC_DISASSOCIATE_REQ, len, SPI_RESP_LEN_MAC_DEFAULT);
//  482       break;
//  483 
//  484     case SPI_CMD_MAC_GET_REQ:
//  485       attr = *pData;
//  486       len = SPI_0DATA_MSG_LEN + ZTEST_DEFAULT_PARAM_LEN;
//  487 
//  488       msg_ptr = osal_mem_alloc( len );
//  489       if ( msg_ptr )
//  490       {
//  491         /* initialize the buffer */
//  492         osal_memset( msg_ptr, 0, len );
//  493 
//  494         /* Call mac_get_req with attr and pointer to first data position*/
//  495         ret = ZMacGetReq( attr, msg_ptr + DATA_BEGIN );
//  496 
//  497         /*
//  498            Build SPI message here instead of redundantly calling MT_BuildSPIMsg
//  499            because we have copied data already in the allocated message
//  500         */
//  501 
//  502         *msg_ptr = SOP_VALUE;
//  503         msg_ptr[CMD_FIELD_HI] =
//  504           (byte)(HI_UINT16( ( uint16 )( SPI_RESPONSE_BIT | SPI_CMD_MAC_GET_REQ )));
//  505 
//  506         msg_ptr[CMD_FIELD_LO] =
//  507           (byte)(LO_UINT16( ( SPI_RESPONSE_BIT | SPI_CMD_MAC_GET_REQ )));
//  508 
//  509         msg_ptr[DATALEN_FIELD] = len - SPI_0DATA_MSG_LEN;
//  510 
//  511         /*
//  512           FCS goes to the last byte in the message and is calculated
//  513           over all the bytes except FCS and SOP
//  514         */
//  515         msg_ptr[len - 1] = SPIMgr_CalcFCS( msg_ptr + 1, (byte)(len-2) );
//  516 
//  517 #if (defined SPI_MGR_DEFAULT_PORT)
//  518         HalUARTWrite ( SPI_MGR_DEFAULT_PORT, msg_ptr, len );
//  519 #endif
//  520         osal_mem_free( msg_ptr );
//  521       }
//  522       break;
//  523 
//  524     case SPI_CMD_MAC_SET_REQ:
//  525       /*
//  526         In the data field of 'msg', the first byte is the attribute and remainder
//  527         is the attribute value. So the pointer 'pData' points directly to the attribute.
//  528         The value of the attribute is from the next byte position
//  529       */
//  530       attr = *pData;
//  531 
//  532       /* special case for beacon payload */
//  533       if ( attr == ZMacBeaconMSDU )
//  534       {
//  535         osal_memcpy( mtMacBeaconPayload, pData + 1, MT_MAC_BEACON_PAYLOAD_MAX );
//  536         ret = ZMacSetReq( (ZMacAttributes_t)attr ,  (byte *) &mtMacBeaconPayload );
//  537       }
//  538       else
//  539       {
//  540         ret = ZMacSetReq( (ZMacAttributes_t)attr , pData + 1 );
//  541       }
//  542       len = SPI_0DATA_MSG_LEN + SPI_RESP_LEN_MAC_DEFAULT;
//  543       MT_SendSPIRespMsg( (byte)ret, SPI_CMD_MAC_SET_REQ, len, SPI_RESP_LEN_MAC_DEFAULT );
//  544       break;
//  545 
//  546     case SPI_CMD_MAC_RESET_REQ:
//  547 
//  548       /*
//  549         The only data byte in the message has a value of 0/1 indicating
//  550         to set the PIB attributes to default values or to leave as is, after reset.
//  551       */
//  552 
//  553       ret = ZMacReset( *pData );
//  554 
//  555       len = SPI_0DATA_MSG_LEN + SPI_RESP_LEN_MAC_DEFAULT;
//  556       MT_SendSPIRespMsg( (byte)ret, SPI_CMD_MAC_RESET_REQ, len, SPI_RESP_LEN_MAC_DEFAULT);
//  557       break;
//  558 
//  559     case SPI_CMD_MAC_GTS_REQ:
//  560       /* Not supported */
//  561       break;
//  562 
//  563     case SPI_CMD_MAC_ORPHAN_RSP:
//  564 
//  565 #if defined( USING_FFDCMAC )
//  566       /* Extended address of the device sending the notification */
//  567       MT_MacRevExtCpy( mtMac.orphanRsp.OrphanAddress, pData );
//  568       pData += Z_EXTADDR_LEN;
//  569 
//  570       /* Short address of the orphan device */
//  571       mtMac.orphanRsp.ShortAddress = BUILD_UINT16( pData[1] , pData[0] );
//  572       pData += 2;
//  573 
//  574       /* Associated member */
//  575       mtMac.orphanRsp.AssociatedMember = *pData++;
//  576 
//  577       /* Security Information */
//  578       MT_MacSpi2Sec( &mtMac.orphanRsp.Sec, pData );
//  579 
//  580       /* Call corresponding ZMAC function */
//  581       ret = ZMacOrphanRsp( &mtMac.orphanRsp );
//  582 #else
//  583       ret = ZMacUnsupportedAttribute;
//  584 #endif // USING_FFDCMAC
//  585 
//  586       len = SPI_0DATA_MSG_LEN + SPI_RESP_LEN_MAC_DEFAULT;
//  587       MT_SendSPIRespMsg( (byte)ret, SPI_CMD_MAC_ORPHAN_RSP, len, SPI_RESP_LEN_MAC_DEFAULT);
//  588       break;
//  589 
//  590     case SPI_CMD_MAC_RX_ENABLE_REQ:
//  591 
//  592       /* First byte - DeferPermit*/
//  593       mtMac.rxEnableReq.DeferPermit = *pData++;
//  594 
//  595       /* RxOnTime */
//  596       mtMac.rxEnableReq.RxOnTime = BUILD_UINT32 (pData[3], pData[2], pData[1], pData[0]);
//  597       pData += 4;
//  598 
//  599       /* RxOnDuration */
//  600       mtMac.rxEnableReq.RxOnDuration = BUILD_UINT32 (pData[3], pData[2], pData[1], pData[0]);
//  601 
//  602       /* Call corresponding ZMAC function */
//  603       ret = ZMacRxEnableReq ( &mtMac.rxEnableReq );
//  604 
//  605       len = SPI_0DATA_MSG_LEN + SPI_RESP_LEN_MAC_DEFAULT;
//  606       MT_SendSPIRespMsg( (byte)ret, SPI_CMD_MAC_RX_ENABLE_REQ, len, SPI_RESP_LEN_MAC_DEFAULT);
//  607       break;
//  608 
//  609     case SPI_CMD_MAC_SYNC_REQ:
//  610 
//  611       /* LogicalChannel */
//  612       mtMac.syncReq.LogicalChannel = *pData++;
//  613 
//  614       /* ChannelPage */
//  615       mtMac.syncReq.ChannelPage = *pData++;
//  616 
//  617       /* TrackBeacon */
//  618       mtMac.syncReq.TrackBeacon    = *pData;
//  619 
//  620       /* Call corresponding ZMAC function */
//  621       ret = ZMacSyncReq( &mtMac.syncReq );
//  622 
//  623       len = SPI_0DATA_MSG_LEN + SPI_RESP_LEN_MAC_DEFAULT;
//  624       MT_SendSPIRespMsg( (byte)ret, SPI_CMD_MAC_SYNC_REQ, len, SPI_RESP_LEN_MAC_DEFAULT);
//  625       break;
//  626 
//  627     case SPI_CMD_MAC_POLL_REQ:
//  628 
//  629       /* Coordinator address mode */
//  630       mtMac.pollReq.CoordAddress.addrMode = *pData++;
//  631 
//  632       /* Coordinator address - Device address mode have to be set to use this function */
//  633       MT_MacSpi2Addr( &mtMac.pollReq.CoordAddress, pData);
//  634       pData += Z_EXTADDR_LEN;
//  635 
//  636       /* Coordinator Pan ID */
//  637       mtMac.pollReq.CoordPanId = BUILD_UINT16( pData[1] , pData[0] );
//  638       pData += 2;
//  639 
//  640       /* Security Information */
//  641       MT_MacSpi2Sec( &mtMac.pollReq.Sec, pData );
//  642 
//  643       /* Call corresponding ZMAC function */
//  644       ret = ZMacPollReq( &mtMac.pollReq );
//  645 
//  646       len = SPI_0DATA_MSG_LEN + SPI_RESP_LEN_MAC_DEFAULT;
//  647       MT_SendSPIRespMsg( (byte)ret, SPI_CMD_MAC_POLL_REQ, len, SPI_RESP_LEN_MAC_DEFAULT);
//  648       break;
//  649 
//  650     case SPI_CMD_MAC_PURGE_REQ:
//  651       /* First and only byte - MsduHandle */
//  652       ret = ZMacPurgeReq (*pData);
//  653 
//  654       len = SPI_0DATA_MSG_LEN + SPI_RESP_LEN_MAC_DEFAULT;
//  655       MT_SendSPIRespMsg( (byte)ret, SPI_CMD_MAC_PURGE_REQ, len, SPI_RESP_LEN_MAC_DEFAULT);
//  656       break;
//  657   }
//  658 }
//  659 
//  660 #if defined ( MT_MAC_CB_FUNC )
//  661 /*********************************************************************
//  662  * @fn          nwk_MTCallbackSubNwkStartCnf
//  663  *
//  664  * @brief       Process the callback subscription for nwk_start_cnf
//  665  *
//  666  * @param       byte Status
//  667  *
//  668  * @return      None
//  669  */
//  670 void nwk_MTCallbackSubNwkStartCnf( byte Status )
//  671 {
//  672   mtOSALSerialData_t  *msgPtr;
//  673   byte                *msg;
//  674 
//  675   msgPtr = MT_MacMsgAllocate( SPI_CB_NWK_START_CNF, SPI_RESP_LEN_MAC_DEFAULT );
//  676   if ( msgPtr )
//  677   {
//  678     msg = msgPtr->msg + DATA_BEGIN;
//  679 
//  680     /* Status */
//  681     *msg = Status;
//  682 
//  683     osal_msg_send( MT_TaskID, (byte *) msgPtr );
//  684   }
//  685 }
//  686 
//  687 /*********************************************************************
//  688  * @fn          nwk_MTCallbackSubNwkDataCnf
//  689  *
//  690  * @brief       Process the callback subscription for nwk_data_cnf
//  691  *
//  692  * @param       pointer of type macnwk_data_cnf_t
//  693  *
//  694  * @return      SUCCESS if message sent succesfully , else N_FAIL
//  695  */
//  696 byte nwk_MTCallbackSubNwkDataCnf( ZMacDataCnf_t *param )
//  697 {
//  698   mtOSALSerialData_t  *msgPtr;
//  699   byte                *msg;
//  700 
//  701   msgPtr = MT_MacMsgAllocate( SPI_CB_NWK_DATA_CNF, SPI_LEN_NWK_DATA_CNF );
//  702   if ( msgPtr )
//  703   {
//  704     msg = msgPtr->msg + DATA_BEGIN;
//  705 
//  706     /* Status */
//  707     *msg++ = param->hdr.Status;
//  708 
//  709     /* Handle */
//  710     *msg++ = param->msduHandle;
//  711 
//  712     /* Timestamp */
//  713     *msg++ = BREAK_UINT32( param->Timestamp, 3 );
//  714     *msg++ = BREAK_UINT32( param->Timestamp, 2 );
//  715     *msg++ = BREAK_UINT32( param->Timestamp, 1 );
//  716     *msg++ = BREAK_UINT32( param->Timestamp, 0 );
//  717 
//  718     /* Timestamp2 */
//  719     *msg++ = HI_UINT16( param->Timestamp2);
//  720     *msg = LO_UINT16( param->Timestamp2);
//  721 
//  722     if ( osal_msg_send( MT_TaskID, (byte *) msgPtr ) == ZSUCCESS )
//  723       return ZMacSuccess;
//  724     else
//  725       return INVALID_TASK;
//  726   }
//  727   else
//  728     return INVALID_TASK;
//  729 }
//  730 
//  731 /*********************************************************************
//  732  * @fn          nwk_MTCallbackSubNwkDataInd
//  733  *
//  734  * @brief       Process the callback subscription for nwk_data_ind
//  735  *
//  736  * @param       pointer of type macnwk_data_ind_t
//  737  *
//  738  * @return      SUCCESS if message sent succesfully , else N_FAIL
//  739  */
//  740 byte nwk_MTCallbackSubNwkDataInd( ZMacDataInd_t *param )
//  741 {
//  742   mtOSALSerialData_t  *msgPtr;
//  743   byte                *msg;
//  744   byte                len;
//  745 
//  746   msgPtr = MT_MacMsgAllocate( SPI_CB_NWK_DATA_IND, SPI_LEN_NWK_DATA_IND + ZTEST_DEFAULT_DATA_LEN );
//  747 
//  748   if ( msgPtr )
//  749   {
//  750     msg = msgPtr->msg + DATA_BEGIN;
//  751 
//  752     /* Src address mode */
//  753     *msg++ = param->SrcAddr.addrMode;
//  754 
//  755     /* Src Address */
//  756     MT_MacAddr2Spi( msg, &param->SrcAddr );
//  757     msg += Z_EXTADDR_LEN;
//  758 
//  759     /* Dst address mode */
//  760     *msg++ = param->DstAddr.addrMode;
//  761 
//  762     /* Dst address */
//  763     MT_MacAddr2Spi( msg, &param->DstAddr );
//  764     msg += Z_EXTADDR_LEN;
//  765 
//  766        /* Timestamp */
//  767     *msg++ = BREAK_UINT32( param->Timestamp, 3 );
//  768     *msg++ = BREAK_UINT32( param->Timestamp, 2 );
//  769     *msg++ = BREAK_UINT32( param->Timestamp, 1 );
//  770     *msg++ = BREAK_UINT32( param->Timestamp, 0 );
//  771 
//  772     /* Timestamp2 */
//  773     *msg++ = HI_UINT16( param->Timestamp2);
//  774     *msg++ = LO_UINT16( param->Timestamp2);
//  775 
//  776     /* Src Pan Id */
//  777     *msg++ = HI_UINT16( param->SrcPANId );
//  778     *msg++ = LO_UINT16( param->SrcPANId );
//  779 
//  780     /* Dst Pan Id */
//  781     *msg++ = HI_UINT16( param->DstPANId );
//  782     *msg++ = LO_UINT16( param->DstPANId );
//  783 
//  784     /* mpdu Link Quality */
//  785     *msg++ = param->mpduLinkQuality;
//  786 
//  787     /* LQI */
//  788     *msg++ = param->Correlation;
//  789 
//  790     /* RSSI */
//  791     *msg++ = param->Rssi;
//  792 
//  793     /* DSN */
//  794     *msg++ = param->Dsn;
//  795 
//  796     /* Security */
//  797     MT_MacSpi2Sec ((ZMacSec_t *)msg, (uint8 *)&param->Sec);
//  798     msg += ZTEST_DEFAULT_SEC_LEN;
//  799 
//  800     /* Copy the data portion - For now, the data must be a fixed length */
//  801     if ( param->msduLength < ZTEST_DEFAULT_DATA_LEN )
//  802       len = param->msduLength;
//  803     else
//  804       len = ZTEST_DEFAULT_DATA_LEN;
//  805 
//  806     *msg++ = len;
//  807     osal_memset( msg, 0, ZTEST_DEFAULT_DATA_LEN );
//  808     osal_memcpy( msg, param->msdu, len );
//  809 
//  810     if ( osal_msg_send( MT_TaskID, (byte *) msgPtr ) == ZSUCCESS )
//  811       return ZMacSuccess;
//  812     else
//  813       return INVALID_TASK;
//  814   }
//  815   else
//  816     return INVALID_TASK;
//  817 }
//  818 
//  819 /*********************************************************************
//  820  * @fn          nwk_MTCallbackSubNwkAssociateCnf
//  821  *
//  822  * @brief       Process the callback subscription for nwk_associate_cnf
//  823  *
//  824  * @param       pointer of type macnwk_associate_cnf_t
//  825  *
//  826  * @return      SUCCESS if message sent succesfully , else N_FAIL
//  827  */
//  828 byte nwk_MTCallbackSubNwkAssociateCnf( ZMacAssociateCnf_t *param )
//  829 {
//  830   mtOSALSerialData_t  *msgPtr;
//  831   byte                *msg;
//  832 
//  833   msgPtr = MT_MacMsgAllocate( SPI_CB_NWK_ASSOCIATE_CNF, SPI_LEN_NWK_ASSOCIATE_CNF );
//  834 
//  835   if ( msgPtr )
//  836   {
//  837     msg = msgPtr->msg + DATA_BEGIN;
//  838 
//  839     /* Status */
//  840     *msg++ = param->hdr.Status;
//  841 
//  842     /* Short address */
//  843     *msg++ = HI_UINT16( param->AssocShortAddress );
//  844     *msg++ = LO_UINT16( param->AssocShortAddress );
//  845 
//  846     /* Security */
//  847     MT_MacSpi2Sec ((ZMacSec_t *)msg, (uint8 *)&param->Sec);
//  848 
//  849     if ( osal_msg_send( MT_TaskID, (byte *) msgPtr ) == ZSUCCESS )
//  850       return ZMacSuccess;
//  851     else
//  852       return INVALID_TASK;
//  853   }
//  854   else
//  855     return INVALID_TASK;
//  856 }
//  857 
//  858 
//  859 /*********************************************************************
//  860  * @fn          nwk_MTCallbackSubNwkAssociateInd
//  861  *
//  862  * @brief       Process the callback subscription for nwk_associate_ind
//  863  *
//  864  * @param       pointer of type macnwk_associate_ind_t
//  865  *
//  866  * @return      SUCCESS if message sent succesfully , else N_FAIL
//  867  *********************************************************************/
//  868 byte nwk_MTCallbackSubNwkAssociateInd( ZMacAssociateInd_t *param )
//  869 {
//  870   mtOSALSerialData_t  *msgPtr;
//  871   byte                *msg;
//  872 
//  873   msgPtr = MT_MacMsgAllocate( SPI_CB_NWK_ASSOCIATE_IND, SPI_LEN_NWK_ASSOCIATE_IND );
//  874 
//  875   if ( msgPtr )
//  876   {
//  877     msg = msgPtr->msg + DATA_BEGIN;
//  878 
//  879     /* Extended address */
//  880     MT_MacRevExtCpy( msg, param->DeviceAddress );
//  881     msg += Z_EXTADDR_LEN;
//  882 
//  883     /* Capability Information */
//  884     *msg++ = param->CapabilityInformation;
//  885 
//  886     /* Security */
//  887     MT_MacSpi2Sec ((ZMacSec_t *)msg, (uint8 *)&param->Sec);
//  888 
//  889     if ( osal_msg_send( MT_TaskID, (byte *) msgPtr ) == ZSUCCESS )
//  890       return ZMacSuccess;
//  891     else
//  892       return INVALID_TASK;
//  893   }
//  894   else
//  895     return INVALID_TASK;
//  896 }
//  897 
//  898 
//  899 
//  900 /*********************************************************************
//  901  * @fn          nwk_MTCallbackSubNwkDisassociateInd
//  902  *
//  903  * @brief       Process the callback subscription for nwk_disassociate_ind
//  904  *
//  905  * @param       pointer of type macnwk_disassociate_ind_t
//  906  *
//  907  * @return      SUCCESS if message sent succesfully , else N_FAIL
//  908  *********************************************************************/
//  909 byte nwk_MTCallbackSubNwkDisassociateInd( ZMacDisassociateInd_t *param )
//  910 {
//  911   mtOSALSerialData_t  *msgPtr;
//  912   byte                *msg;
//  913 
//  914   msgPtr = MT_MacMsgAllocate( SPI_CB_NWK_DISASSOCIATE_IND, SPI_LEN_NWK_DISASSOCIATE_IND );
//  915 
//  916   if ( msgPtr )
//  917   {
//  918     msg = msgPtr->msg + DATA_BEGIN;
//  919 
//  920     /* Extended address */
//  921     MT_MacRevExtCpy( msg, param->DeviceAddress );
//  922     msg += Z_EXTADDR_LEN;
//  923 
//  924     /* Disassociate Reason */
//  925     *msg++ = param->DisassociateReason;
//  926 
//  927     /* Security */
//  928     MT_MacSpi2Sec ((ZMacSec_t *)msg, (uint8 *)&param->Sec);
//  929 
//  930     if ( osal_msg_send( MT_TaskID, (byte *) msgPtr ) == ZSUCCESS )
//  931       return ZMacSuccess;
//  932     else
//  933       return INVALID_TASK;
//  934     }
//  935     else
//  936       return INVALID_TASK;
//  937 }
//  938 
//  939 /*********************************************************************
//  940  * @fn          nwk_MTCallbackSubNwkDisassociateCnf
//  941  *
//  942  * @brief       Process the callback subscription for nwk_disassociate_cnf
//  943  *
//  944  * @param       param
//  945  *
//  946  * @return      SUCCESS if message sent succesfully , else N_FAIL
//  947  *********************************************************************/
//  948 byte nwk_MTCallbackSubNwkDisassociateCnf( ZMacDisassociateCnf_t *param )
//  949 {
//  950   mtOSALSerialData_t  *msgPtr;
//  951   byte                *msg;
//  952 
//  953   msgPtr = MT_MacMsgAllocate( SPI_CB_NWK_DISASSOCIATE_CNF, SPI_LEN_NWK_DISASSOCIATE_CNF );
//  954 
//  955   if ( msgPtr )
//  956   {
//  957     msg = msgPtr->msg + DATA_BEGIN;
//  958 
//  959     /* Status */
//  960     *msg++ = param->hdr.Status;
//  961 
//  962     /* DeviceAddress */
//  963     *msg++ = param->DeviceAddress.addrMode;
//  964 
//  965     /* Copy Address */
//  966     MT_MacAddr2Spi( msg, &param->DeviceAddress );
//  967     msg += Z_EXTADDR_LEN;
//  968 
//  969     /* Pan ID */
//  970     *msg++ = HI_UINT16( param->panID );
//  971     *msg = LO_UINT16( param->panID );
//  972 
//  973     if ( osal_msg_send( MT_TaskID, (byte *) msgPtr ) == ZSUCCESS )
//  974       return ZMacSuccess;
//  975     else
//  976       return INVALID_TASK;
//  977   }
//  978   else
//  979     return INVALID_TASK;
//  980 }
//  981 
//  982 /*********************************************************************
//  983  * @fn          nwk_MTCallbackSubNwkOrphanInd
//  984  *
//  985  * @brief       Process the callback subscription for nwk_orphan_ind
//  986  *
//  987  * @param       pointer of type macnwk_orphan_ind_t
//  988  *
//  989  * @return      SUCCESS if message sent succesfully , else N_FAIL
//  990  *********************************************************************/
//  991 byte nwk_MTCallbackSubNwkOrphanInd( ZMacOrphanInd_t *param )
//  992 {
//  993   mtOSALSerialData_t  *msgPtr;
//  994   byte                *msg;
//  995 
//  996   msgPtr = MT_MacMsgAllocate( SPI_CB_NWK_ORPHAN_IND, SPI_LEN_NWK_ORPHAN_IND );
//  997 
//  998   if ( msgPtr )
//  999   {
// 1000     msg = msgPtr->msg + DATA_BEGIN;
// 1001 
// 1002     /* Extended address */
// 1003     MT_MacRevExtCpy( msg, param->OrphanAddress );
// 1004     msg += Z_EXTADDR_LEN;
// 1005 
// 1006     /* Security */
// 1007     MT_MacSpi2Sec ((ZMacSec_t *)msg, (uint8 *)&param->Sec);
// 1008 
// 1009     if ( osal_msg_send( MT_TaskID, (byte *) msgPtr ) == ZSUCCESS )
// 1010       return ZMacSuccess;
// 1011     else
// 1012       return INVALID_TASK;
// 1013   }
// 1014   else
// 1015     return INVALID_TASK;
// 1016 }
// 1017 
// 1018 /*********************************************************************
// 1019  * @fn          nwk_MTCallbackSubNwkScanCnf
// 1020  *
// 1021  * @brief       Process the callback subscription for nwk_scan_cnf
// 1022  *
// 1023  * @param       pointer of type macnwk_scan_cnf_t
// 1024  *
// 1025  * @return      SUCCESS if message sent succesfully , else N_FAIL
// 1026  */
// 1027 byte nwk_MTCallbackSubNwkScanCnf( ZMacScanCnf_t *param )
// 1028 {
// 1029   mtOSALSerialData_t  *msgPtr;
// 1030   byte                *msg;
// 1031   byte                resultLen;
// 1032 
// 1033   if ( param->ScanType == ZMAC_ED_SCAN )
// 1034     resultLen = MT_MAC_ED_SCAN_MAXCHANNELS;
// 1035   else if ( param->ScanType == ZMAC_ACTIVE_SCAN )
// 1036     resultLen = (param->ResultListSize * sizeof( ZMacPanDesc_t ));
// 1037   else if ( param->ScanType == ZMAC_PASSIVE_SCAN )
// 1038     resultLen = (param->ResultListSize * sizeof( ZMacPanDesc_t ));
// 1039   else if ( param->ScanType == ZMAC_ORPHAN_SCAN )
// 1040     resultLen = 0;
// 1041   else
// 1042     return INVALID_EVENT_ID;
// 1043 
// 1044   resultLen = MIN(resultLen, MT_MAC_SCAN_RESULT_LEN_MAX);
// 1045 
// 1046   msgPtr = MT_MacMsgAllocate( SPI_CB_NWK_SCAN_CNF, SPI_LEN_NWK_SCAN_CNF + MT_MAC_SCAN_RESULT_LEN_MAX );
// 1047 
// 1048   if ( msgPtr )
// 1049   {
// 1050     msg = msgPtr->msg + DATA_BEGIN;
// 1051 
// 1052     /* Status */
// 1053     *msg++ = param->hdr.Status;
// 1054 
// 1055     /* ED max energy parameter no longer used */
// 1056     *msg++ = 0;
// 1057 
// 1058     /* Scan type */
// 1059     *msg++ = param->ScanType;
// 1060 
// 1061     /* Channel page */
// 1062     *msg++ = param->ChannelPage;
// 1063 
// 1064     /* Unscanned channel list */
// 1065     *msg++ = BREAK_UINT32( param->UnscannedChannels, 3 );
// 1066     *msg++ = BREAK_UINT32( param->UnscannedChannels, 2 );
// 1067     *msg++ = BREAK_UINT32( param->UnscannedChannels, 1 );
// 1068     *msg++ = BREAK_UINT32( param->UnscannedChannels, 0 );
// 1069 
// 1070     /* Result count */
// 1071     *msg++ = param->ResultListSize;
// 1072 
// 1073     /* PAN descriptor information */
// 1074     osal_memcpy( msg, param->Result.pPanDescriptor, resultLen );
// 1075 
// 1076     /* clear extra buffer space at end, if any */
// 1077     osal_memset( msg, 0, (MT_MAC_SCAN_RESULT_LEN_MAX - resultLen));
// 1078 
// 1079     if ( osal_msg_send( MT_TaskID, (byte *) msgPtr ) == ZSUCCESS )
// 1080       return ZMacSuccess;
// 1081     else
// 1082       return INVALID_TASK;
// 1083   }
// 1084   else
// 1085     return INVALID_TASK;
// 1086 }
// 1087 
// 1088 /*********************************************************************
// 1089  * @fn          nwk_MTCallbackSubNwkPollCnf
// 1090  *
// 1091  * @brief       Process the callback subscription for nwk_poll_cnf
// 1092  *
// 1093  * @param       byte Status
// 1094  *
// 1095  * @return      SUCCESS if message sent succesfully , else N_FAIL
// 1096  */
// 1097 byte nwk_MTCallbackSubNwkPollCnf( byte Status )
// 1098 {
// 1099   mtOSALSerialData_t  *msgPtr;
// 1100   byte                *msg;
// 1101 
// 1102   msgPtr = MT_MacMsgAllocate( SPI_CB_NWK_POLL_CNF, SPI_RESP_LEN_MAC_DEFAULT );
// 1103 
// 1104   if ( msgPtr )
// 1105   {
// 1106     msg = msgPtr->msg + DATA_BEGIN;
// 1107 
// 1108     //The only data byte is Status
// 1109     *msg = Status;
// 1110 
// 1111     if ( osal_msg_send( MT_TaskID, (byte *) msgPtr ) == ZSUCCESS )
// 1112       return ZMacSuccess;
// 1113     else
// 1114       return INVALID_TASK;
// 1115   }
// 1116   else
// 1117     return INVALID_TASK;
// 1118 }
// 1119 
// 1120 /*********************************************************************
// 1121  * @fn          nwk_MTCallbackSubNwkSyncLossInd
// 1122  *
// 1123  * @brief       Process the callback subscription for nwk_sync_loss_ind
// 1124  *
// 1125  * @param       byte LossReason
// 1126  *
// 1127  * @return      SUCCESS if message sent succesfully , else N_FAIL
// 1128  */
// 1129 byte nwk_MTCallbackSubNwkSyncLossInd( ZMacSyncLossInd_t *param )
// 1130 {
// 1131   mtOSALSerialData_t  *msgPtr;
// 1132   byte                *msg;
// 1133 
// 1134   msgPtr = MT_MacMsgAllocate( SPI_CB_NWK_SYNC_LOSS_IND, SPI_LEN_NWK_SYNC_LOSS_IND );
// 1135 
// 1136   if ( msgPtr )
// 1137   {
// 1138     msg = msgPtr->msg + DATA_BEGIN;
// 1139 
// 1140     /*  Status - loss reason */
// 1141     *msg++ = param->hdr.Status;
// 1142 
// 1143     /* Pan Id */
// 1144     *msg++ = HI_UINT16( param->PANId );
// 1145     *msg++ = LO_UINT16( param->PANId );
// 1146 
// 1147     /* Logical Channel */
// 1148     *msg++ = param->LogicalChannel;
// 1149 
// 1150     /* Channel Page */
// 1151     *msg++ = param->ChannelPage;
// 1152 
// 1153     /* Security */
// 1154     MT_MacSpi2Sec ((ZMacSec_t *)msg, (uint8 *)&param->Sec);
// 1155 
// 1156     if ( osal_msg_send( MT_TaskID, (byte *) msgPtr ) == ZSUCCESS )
// 1157       return ZMacSuccess;
// 1158     else
// 1159       return INVALID_TASK;
// 1160   }
// 1161   else
// 1162     return INVALID_TASK;
// 1163 }
// 1164 
// 1165 /*********************************************************************
// 1166  * @fn          nwk_MTCallbackSubNwkRxEnableCnf
// 1167  *
// 1168  * @brief       Process the callback subscription for nwk_Rx_Enable_cnf
// 1169  *
// 1170  * @param
// 1171  *
// 1172  * @return      SUCCESS if message sent succesfully , else N_FAIL
// 1173  */
// 1174 byte nwk_MTCallbackSubNwkRxEnableCnf ( byte Status )
// 1175 {
// 1176   mtOSALSerialData_t  *msgPtr;
// 1177   byte                *msg;
// 1178 
// 1179   msgPtr = MT_MacMsgAllocate( SPI_CB_NWK_RX_ENABLE_CNF, SPI_RESP_LEN_MAC_DEFAULT );
// 1180 
// 1181   if ( msgPtr )
// 1182   {
// 1183     msg = msgPtr->msg + DATA_BEGIN;
// 1184 
// 1185     /* The only data byte is Status */
// 1186     *msg = Status;
// 1187 
// 1188     if ( osal_msg_send( MT_TaskID, (byte *) msgPtr ) == ZSUCCESS )
// 1189       return ZMacSuccess;
// 1190     else
// 1191       return INVALID_TASK;
// 1192   }
// 1193   else
// 1194     return INVALID_TASK;
// 1195 }
// 1196 
// 1197 /*********************************************************************
// 1198  * @fn          nwk_MTCallbackSubCommStatusInd
// 1199  *
// 1200  * @brief       Process the callback subscription for
// 1201  *              comm_status_ind.
// 1202  *
// 1203  * @param
// 1204  *
// 1205  * @return      SUCCESS if message sent succesfully , else N_FAIL
// 1206  */
// 1207 byte nwk_MTCallbackSubCommStatusInd ( ZMacCommStatusInd_t *param )
// 1208 {
// 1209   mtOSALSerialData_t  *msgPtr;
// 1210   byte                *msg;
// 1211 
// 1212   msgPtr = MT_MacMsgAllocate( SPI_CB_NWK_COMM_STATUS_IND, SPI_LEN_NWK_COMM_STATUS_IND );
// 1213 
// 1214   if ( msgPtr )
// 1215   {
// 1216     msg = msgPtr->msg + DATA_BEGIN;
// 1217 
// 1218     /* Status */
// 1219     *msg++ = param->hdr.Status;
// 1220 
// 1221     /* Source address */
// 1222     *msg++ = param->SrcAddress.addrMode;
// 1223     MT_MacAddr2Spi( msg, &param->SrcAddress );
// 1224     msg += Z_EXTADDR_LEN;
// 1225 
// 1226     /* Destination address */
// 1227     *msg++ = param->DstAddress.addrMode;
// 1228     MT_MacAddr2Spi( msg, &param->DstAddress );
// 1229     msg += Z_EXTADDR_LEN;
// 1230 
// 1231     /* PAN ID */
// 1232     *msg++ = HI_UINT16( param->PANId );
// 1233     *msg++ = LO_UINT16( param->PANId );
// 1234 
// 1235     /* Reason */
// 1236     *msg++ = param->Reason;
// 1237 
// 1238     /* Security */
// 1239     MT_MacSpi2Sec ((ZMacSec_t *)msg, (uint8 *)&param->Sec);
// 1240 
// 1241     if ( osal_msg_send( MT_TaskID, (byte *) msgPtr ) == ZSUCCESS )
// 1242       return ZMacSuccess;
// 1243     else
// 1244       return INVALID_TASK;
// 1245   }
// 1246   else
// 1247     return INVALID_TASK;
// 1248 }
// 1249 
// 1250 /*********************************************************************
// 1251  * @fn          nwk_MTCallbackSubNwkPurgeCnf
// 1252  *
// 1253  * @brief       Process the callback subscription for nwk_purge_cnf
// 1254  *
// 1255  * @param       pointer of type ZMacPurgeCnf_t
// 1256  *
// 1257  * @return      SUCCESS if message sent succesfully , else N_FAIL
// 1258  */
// 1259 byte nwk_MTCallbackSubNwkPurgeCnf( ZMacPurgeCnf_t *param )
// 1260 {
// 1261   mtOSALSerialData_t  *msgPtr;
// 1262   byte                *msg;
// 1263 
// 1264   msgPtr = MT_MacMsgAllocate( SPI_CB_NWK_PURGE_CNF, SPI_LEN_NWK_PURGE_CNF );
// 1265   if ( msgPtr )
// 1266   {
// 1267     msg = msgPtr->msg + DATA_BEGIN;
// 1268 
// 1269     /* Status */
// 1270     *msg = param->hdr.Status;
// 1271 
// 1272     /* Handle */
// 1273     *msg++ = param->msduHandle;
// 1274 
// 1275     if ( osal_msg_send( MT_TaskID, (byte *) msgPtr ) == ZSUCCESS )
// 1276       return ZMacSuccess;
// 1277     else
// 1278       return INVALID_TASK;
// 1279   }
// 1280   else
// 1281     return INVALID_TASK;
// 1282 }
// 1283 
// 1284 /*********************************************************************
// 1285  * @fn          nwk_MTCallbackSubNwkBeaconNotifyInd
// 1286  *
// 1287  * @brief       Process the callback subscription for
// 1288  *              beacon_notify_ind.
// 1289  *
// 1290  * @param
// 1291  *
// 1292  * @return      SUCCESS if message sent succesfully , else N_FAIL
// 1293  */
// 1294 byte nwk_MTCallbackSubNwkBeaconNotifyInd ( ZMacBeaconNotifyInd_t *param )
// 1295 {
// 1296   mtOSALSerialData_t  *msgPtr;
// 1297   byte                *msg;
// 1298 
// 1299   msgPtr = MT_MacMsgAllocate( SPI_CB_NWK_BEACON_NOTIFY_IND, SPI_LEN_NWK_BEACON_NOTIFY_IND );
// 1300   if ( msgPtr )
// 1301   {
// 1302     msg = msgPtr->msg + DATA_BEGIN;
// 1303 
// 1304     /* BSN */
// 1305     *msg++ = param->BSN;
// 1306 
// 1307     /* Timestamp */
// 1308     *msg++ = BREAK_UINT32( param->pPanDesc->TimeStamp, 3 );
// 1309     *msg++ = BREAK_UINT32( param->pPanDesc->TimeStamp, 2 );
// 1310     *msg++ = BREAK_UINT32( param->pPanDesc->TimeStamp, 1 );
// 1311     *msg++ = BREAK_UINT32( param->pPanDesc->TimeStamp, 0 );
// 1312 
// 1313     /* Coordinator address mode */
// 1314     *msg++ = param->pPanDesc->CoordAddress.addrMode;
// 1315 
// 1316     /* Coordinator address */
// 1317     MT_MacAddr2Spi( msg, &param->pPanDesc->CoordAddress );
// 1318     msg += Z_EXTADDR_LEN;
// 1319 
// 1320     /* PAN ID */
// 1321     *msg++ = HI_UINT16( param->pPanDesc->CoordPANId );
// 1322     *msg++ = LO_UINT16( param->pPanDesc->CoordPANId );
// 1323 
// 1324     /* Superframe spec */
// 1325     *msg++ = HI_UINT16( param->pPanDesc->SuperframeSpec );
// 1326     *msg++ = LO_UINT16( param->pPanDesc->SuperframeSpec );
// 1327 
// 1328     /* LogicalChannel */
// 1329     *msg++ = param->pPanDesc->LogicalChannel;
// 1330 
// 1331     /* GTSPermit */
// 1332     *msg++ = param->pPanDesc->GTSPermit;
// 1333 
// 1334     /* LinkQuality */
// 1335     *msg++ = param->pPanDesc->LinkQuality;
// 1336 
// 1337     /* SecurityFailure */
// 1338     *msg++ = param->pPanDesc->SecurityFailure;
// 1339 
// 1340     /* Security */
// 1341     MT_MacSpi2Sec ((ZMacSec_t *)msg, (uint8 *)&param->pPanDesc->Sec);
// 1342     msg += ZTEST_DEFAULT_SEC_LEN;
// 1343 
// 1344     /* PendingAddrSpec */
// 1345     *msg++ = param->PendAddrSpec;
// 1346 
// 1347     /* AddrList */
// 1348     osal_memset( msg, 0, MT_MAC_PEND_LEN_MAX );
// 1349     osal_memcpy( msg, param->AddrList, MIN(MT_MAC_PEND_LEN_MAX, MT_MAC_PEND_LEN(param->PendAddrSpec)) );
// 1350     msg += MT_MAC_PEND_LEN_MAX;
// 1351 
// 1352     /* SDULength */
// 1353     *msg++ = param->sduLength;
// 1354 
// 1355     /* SDU */
// 1356     osal_memset( msg, 0, MT_MAC_SDU_LEN_MAX );
// 1357     osal_memcpy( msg, param->sdu, MIN(MT_MAC_SDU_LEN_MAX, param->sduLength) );
// 1358     //msg += MT_MAC_SDU_LEN_MAX;
// 1359 
// 1360     if ( osal_msg_send( MT_TaskID, (byte *) msgPtr ) == ZSUCCESS )
// 1361       return ZMacSuccess;
// 1362     else
// 1363       return INVALID_TASK;
// 1364   }
// 1365   else
// 1366     return INVALID_TASK;
// 1367 }
// 1368 
// 1369 #endif // MT_MAC_CB_FUNC
// 1370 
// 1371 /*********************************************************************
// 1372 *********************************************************************/
// 1373 #endif // MT_MAC_FUNC
// 
// 
// 0 bytes of memory
//
//Errors: none
//Warnings: none
