###############################################################################
#                                                                             #
# IAR C/C++ Compiler V7.60.1.40026 for 8051             23/Oct/2018  17:27:19 #
# Copyright (C) 2004-2010 IAR Systems AB.                                     #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\src\MobilePhone.c                        #
#    Command line       =  E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\src\MobilePhone.c -D xSMS_TEMPLATE -D    #
#                          MENU_CLOCKFORMAT -D CELLSWITCH_DEBUG -D            #
#                          MP_INFORMATION -D HOLD_AUTO_START -D SMS_SENDBOX   #
#                          -D NEW_MENU_LIB -D WATCHDOG=TRUE -D                #
#                          NEW_DOUBLE_NVID_OP -D AUDIO_SERIAL -D              #
#                          NWK_AUTO_POLL -D OSC32K_CRYSTAL_INSTALLED=FALSE    #
#                          -D xAUDIO_TEST -D xSINGLE_AUDIO_TEST -D            #
#                          xMULTIAUDIO_TEST -D xREFLECTOR -D xLCD_SUPPORTED   #
#                          -D HAL_LCD=FALSE -D HAL_AUDIO=TRUE -D              #
#                          HAL_SPI=FALSE -D HAL_UART=FALSE -D HAL_LED=FALSE   #
#                          -D HAL_AES=FALSE -D HAL_KEY=TRUE -D                #
#                          IDX_THRESHOLD=12 -D xMACNODEBUG -D                 #
#                          xMAC_NO_PARAM_CHECK -D HAL_AUDIO=TRUE -D           #
#                          HAL_DMA=TRUE -D HAL_AES=FALSE -D                   #
#                          MAC_CFG_TX_DATA_MAX=8 -D MAC_CFG_TX_MAX=12 -D      #
#                          MAC_CFG_RX_MAX=8 -lcN E:\p4\main\Zigbee\cc2530\min #
#                          e_project_voice\app\MobilePhone\iar\Release\List\  #
#                          -lb E:\p4\main\Zigbee\cc2530\mine_project_voice\ap #
#                          p\MobilePhone\iar\Release\List\ -o                 #
#                          E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\Release\Obj\ -e                      #
#                          --require_prototypes --no_unroll --no_inline       #
#                          --no_code_motion --debug --core=plain --dptr=16,1  #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I E:\p4\main\Zigbee\cc2530\mine_project_voice\app #
#                          \MobilePhone\iar\..\src\ -I                        #
#                          E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\..\src\MenuLib\ -I                   #
#                          E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\..\src\MenuLib\util\ -I              #
#                          E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\..\..\..\third_party\TIMAC-CC2530-1. #
#                          3.1\COMPONENTS\MAC\INCLUDE\ -I                     #
#                          E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\..\..\..\third_party\TIMAC-CC2530-1. #
#                          3.1\COMPONENTS\MAC\HIGH_LEVEL\ -I                  #
#                          E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\..\..\..\third_party\TIMAC-CC2530-1. #
#                          3.1\COMPONENTS\MAC\LOW_LEVEL\ -I                   #
#                          E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\..\..\..\third_party\TIMAC-CC2530-1. #
#                          3.1\COMPONENTS\MAC\LOW_LEVEL\SRF04\ -I             #
#                          E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\..\..\..\third_party\TIMAC-CC2530-1. #
#                          3.1\COMPONENTS\MAC\LOW_LEVEL\SRF04\SINGLE_CHIP\    #
#                          -I E:\p4\main\Zigbee\cc2530\mine_project_voice\app #
#                          \MobilePhone\iar\..\..\..\third_party\TIMAC-CC2530 #
#                          -1.3.1\COMPONENTS\OSAL\INCLUDE\ -I                 #
#                          E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\..\..\..\third_party\TIMAC-CC2530-1. #
#                          3.1\COMPONENTS\OSAL\MCU\CC2530\ -I                 #
#                          E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\..\..\..\third_party\TIMAC-CC2530-1. #
#                          3.1\COMPONENTS\SERVICES\SADDR\ -I                  #
#                          E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\..\..\..\third_party\TIMAC-CC2530-1. #
#                          3.1\COMPONENTS\SERVICES\SDATA\ -I                  #
#                          E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\..\..\..\third_party\TIMAC-CC2530-1. #
#                          3.1\COMPONENTS\MT\ -I E:\p4\main\Zigbee\cc2530\min #
#                          e_project_voice\app\MobilePhone\iar\..\..\..\..\.. #
#                          \..\common\ -I E:\p4\main\Zigbee\cc2530\mine_proje #
#                          ct_voice\app\MobilePhone\iar\..\..\..\..\..\common #
#                          \lcd\ -I E:\p4\main\Zigbee\cc2530\mine_project_voi #
#                          ce\app\MobilePhone\iar\..\..\..\..\..\..\common\2g #
#                          \ -I E:\p4\main\Zigbee\cc2530\mine_project_voice\a #
#                          pp\MobilePhone\iar\..\..\..\..\..\..\ -I           #
#                          E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\..\..\..\driver\ -I                  #
#                          E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\..\..\..\util\ -I                    #
#                          E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\..\..\..\driver\include\ -I          #
#                          E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\..\..\..\driver\common\ -I           #
#                          E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\..\..\..\driver\MobilePhone\ -I      #
#                          E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\..\..\..\driver\MobilePhone\audio\   #
#                          -I E:\p4\main\Zigbee\cc2530\mine_project_voice\app #
#                          \MobilePhone\iar\..\..\..\driver\MobilePhone\commo #
#                          n\ -I E:\p4\main\Zigbee\cc2530\mine_project_voice\ #
#                          app\MobilePhone\iar\..\..\..\driver\MobilePhone\ke #
#                          y\ -I E:\p4\main\Zigbee\cc2530\mine_project_voice\ #
#                          app\MobilePhone\iar\..\..\..\driver\MobilePhone\lc #
#                          d\ -I E:\p4\main\Zigbee\cc2530\mine_project_voice\ #
#                          app\MobilePhone\iar\..\..\..\driver\MobilePhone\io #
#                          expand\ -I "C:\Program Files\IAR Systems\Embedded  #
#                          Workbench 5.4\8051\INC\" -I "C:\Program Files\IAR  #
#                          Systems\Embedded Workbench 5.4\8051\INC\CLIB\"     #
#                          -Ohs                                               #
#    List file          =  E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\Release\List\MobilePhone.lst         #
#    Object file        =  E:\p4\main\Zigbee\cc2530\mine_project_voice\app\Mo #
#                          bilePhone\iar\Release\Obj\MobilePhone.r51          #
#                                                                             #
#                                                                             #
###############################################################################

E:\p4\main\Zigbee\cc2530\mine_project_voice\app\MobilePhone\src\MobilePhone.c
      1          /**************************************************************************************************
      2          Filename:       MobilePhone.c
      3          Revised:        $Date: 2011/08/24 18:05:00 $
      4          Revision:       $Revision: 1.22 $
      5          
      6          Description:    This file contains the sample application that can be use to test
      7          the functionality of the MAC, HAL and low level.
      8          
      9          **************************************************************************************************/
     10          
     11          /**************************************************************************************************
     12          
     13          Description:
     14          
     15          **************************************************************************************************/
     16          
     17          
     18          /**************************************************************************************************
     19          *                                           Includes
     20          **************************************************************************************************/
     21          
     22          /* Hal Driver includes */
     23          #include "hal_types.h"
     24          #include "hal_key.h"
     25          #include "hal_timer.h"
     26          #include "hal_led.h"
     27          #include "hal_adc.h"
     28          #include "hal_lcd.h"
     29          #include "hal_audio.h"
     30          #include "hal_assert.h"
     31          #include "hal_alarm.h"
     32          #include "hal_drivers.h"
     33          #include "hal_flash.h"
     34          
     35          /* OS includes */
     36          #include "ZComdef.h"
     37          #include "OSAL.h"
     38          #include "OSAL_Nv.h"
     39          #include "OSAL_Tasks.h"
     40          #include "OSAL_PwrMgr.h"
     41          
     42          /* Application Includes */
     43          #include "OnBoard.h"
     44          
     45          /* MAC Application Interface */
     46          #include "mac_api.h"
     47          #include "mac_main.h"
     48          #include "mac_radio_defs.h"
     49          #include "mac_spec.h"
     50          #include "Mac_api.h"
     51          #include "App_cfg.h"
     52          #include "timeUtil.h"
     53          #include "stringUtil.h"
     54          #include "WatchDogUtil.h"
     55          #include "numtrans.h"
     56          
     57          #include "hal_uart.h"
     58          /* Application */
     59          #include "MobilePhone.h"
     60          #include "MobilePhone_Function.h"
     61          #include "MobilePhone_global.h"
     62          #include "MobilePhone_Menulib.h"
     63          
     64          #include "MenuLib_Nv.h"
     65          #include "MobilePhone_Function.h"
     66          
     67          #define UARTSTATE_PREAMBLE_Y 0
     68          #define UARTSTATE_PREAMBLE_I 1
     69          #define UARTSTATE_PREAMBLE_R 2
     70          #define UARTSTATE_DATA       3
     71          
     72          #define CARD_STATUS_NORMAL   0
     73          #define CARD_STATUS_HELP     1
     74          
     75          
     76          #ifdef CFG_STATION_CHECK
     77          #include "Mac_low_level.h"
     78          #include "MenuLib_tree.h"
     79          extern uint8 macChipVersion;
     80          #endif
     81          extern uint8 contact_item_L[MAX_CONTACT_NUM];
     82          bool  Menu_rf_debug=false;
     83          bool  Rssi_information=false;
     84          bool  Packge_information=false;
     85          uint8 uartReadBuf[128];
     86          uint8 uartlen;
     87          uint8 uart_recv_state = UARTSTATE_PREAMBLE_Y;
     88          uint8 card_status = CARD_STATUS_NORMAL;
     89          /**************************************************************************************************
     90          *                                           Constant
     91          **************************************************************************************************/
     92          
     93          /* Size table for MAC structures */
     94          const CODE uint8 MP_cbackSizeTable [] =
     95          {
     96              0,                                   /* unused */
     97              sizeof(macMlmeAssociateInd_t),       /* MAC_MLME_ASSOCIATE_IND */
     98              sizeof(macMlmeAssociateCnf_t),       /* MAC_MLME_ASSOCIATE_CNF */
     99              sizeof(macMlmeDisassociateInd_t),    /* MAC_MLME_DISASSOCIATE_IND */
    100              sizeof(macMlmeDisassociateCnf_t),    /* MAC_MLME_DISASSOCIATE_CNF */
    101              sizeof(macMlmeBeaconNotifyInd_t),    /* MAC_MLME_BEACON_NOTIFY_IND */
    102              sizeof(macMlmeOrphanInd_t),          /* MAC_MLME_ORPHAN_IND */
    103              sizeof(macMlmeScanCnf_t),            /* MAC_MLME_SCAN_CNF */
    104              sizeof(macMlmeStartCnf_t),           /* MAC_MLME_START_CNF */
    105              sizeof(macMlmeSyncLossInd_t),        /* MAC_MLME_SYNC_LOSS_IND */
    106              sizeof(macMlmePollCnf_t),            /* MAC_MLME_POLL_CNF */
    107              sizeof(macMlmeCommStatusInd_t),      /* MAC_MLME_COMM_STATUS_IND */
    108              sizeof(macMcpsDataCnf_t),            /* MAC_MCPS_DATA_CNF */
    109              sizeof(macMcpsDataInd_t),            /* MAC_MCPS_DATA_IND */
    110              sizeof(macMcpsPurgeCnf_t),           /* MAC_MCPS_PURGE_CNF */
    111              sizeof(macEventHdr_t)                /* MAC_PWR_ON_CNF */
    112          };
    113          
    114          /* TRUE and FALSE value */
    115          bool          MP_MACTrue = TRUE;
    116          bool          MP_MACFalse = FALSE;
    117          
    118          /**************************************************************************************************
    119          *                                        extern  Variables
    120          **************************************************************************************************/
    121          
    122          /* Task ID */
    123          uint8 MP_TaskId;
    124          uint8 MP_RFState = 0;
    125          /**************************************************************************************************
    126          *                                         Typedefs
    127          **************************************************************************************************/
    128          
    129          #if  1//def PACKAGE_INFORMATION
    130          typedef struct
    131          {
    132              uint16 err_cnt;
    133              uint16 recv_cnt;
    134              uint16 send_cnt;
    135          } MP_packet_info_t;
    136          #endif
    137          
    138          /*typedef struct
    139          {
    140              uint_16 u16ShortAddr;
    141              int_8 i8Rssi;
    142              uint_8 u8Reserved;
    143          } vehicle_rssi_ts;*/
    144          
    145          
    146          /*typedef struct
    147          {
    148              uint_16 u16station_addr;
    149              uint_16 u16seqnum;
    150              vehicle_rssi_ts vehicle_rssi[10];    // the length(app_tof_head.len) of this array is alterable, max length is APP_MAX_CARD_NUM
    151          } app_vehicle_rssi_ts;*/
    152          
    153          
    154          
    155          
    156          /**************************************************************************************************
    157          *                                        Local Variables
    158          **************************************************************************************************/
    159          
    160          #if  1//def PACKAGE_INFORMATION
    161          static MP_packet_info_t MP_packet_info;
    162          #endif
    163          
    164          static uint8   MP_RejoinTimes;
    165          uint8  signal_update_count=10;
    166          
    167          //8*2+1
    168          static char MP_numstr[21];
    169          
    170          uint8   MP_VoiceBuf[VOICE_IDX_THRESHOLD *VOICE_PER_RAW_DATA_LEN];
    171          
    172          typedef struct
    173          {
    174              uint_16 u16station_addr;
    175              uint_16 u16seqnum;
    176              vehicle_rssi_ts vehicle_rssi[10];    // the length(app_tof_head.len) of this array is alterable, max length is APP_MAX_CARD_NUM
    177          } vehicle_rssi_tsD;
    178          
    179          
    180          static vehicle_rssi_tsD vehicle_rssi_data;
    181          static uint16 u16RssiNum = 0;
    182          
    183          
    184          /*************************************************************************************************
    185          *MACROS
    186          */
    187          
    188          /**************************************************************************************************
    189          *                                     Local Function Prototypes
    190          **************************************************************************************************/
    191          static void MP_DeviceStartup(void);
    192          static uint8  MP_ReadExtAddr(void);
    193          static byte MP_ParseAppFrame(const sData_t data, uint16 panid, uint16 shortAddr , int8 rssi);
    194          static void MP_ParseVoice(const app_mpVoice_t *pVoice, int8 rssi);
    195          static void MP_ParseCmd(const app_mpCmd_t *pCmd);
    196          //static void MP_ParseSms(app_mpSMS_t *pSms);
    197          static void MP_ParseJoin(app_mpJoinNwk_t *p, uint16 panid, int8 rssi);
    198          static void MP_ParseTime(app_mpTime_t *p);
    199          static void MP_ParsePoll(app_mpPoll_t *p, int8 rssi);
    200          static bool MP_CellSwitchCondition(uint16 panid, int8 rssi);
    201          static int8  MP_SearchCellInfo(uint16 panid, int8 rssi);
    202          static bool  MP_SilenceSignCheck(uint16 sign, uint8 datasize);
    203          static void MP_ReadR_or_DInfo(void);
    204          void MP_SetR_or_DInfo(void);
    205          void MP_to_release_vesion(void);
    206          
    207          void ReportVehicleCardRssi(void);
    208          
    209          void SysUtil_vConvertEndian(void* pvData, uint8 u8Len);
    210          uint8 Mp_num_isequal(const app_termNbr_t *p1, const app_termNbr_t *p2);
    211          
    212          
    213          void init_uart(uint8  uartPort , uint8 baudRate);
    214          #ifdef CFG_STATION_CHECK
    215          static void MP_Station_Signal_Update(void);
    216          #endif
    217          int seqnumerrcnt=0;
    218          /**************************************************************************************************
    219          *
    220          * @fn          MP_Init
    221          *
    222          * @brief       Initialize the application
    223          *
    224          * @param       taskId - taskId of the task after it was added in the OSAL task queue
    225          *
    226          * @return      none
    227          *
    228          **************************************************************************************************/
    229          void MP_Init(uint8 taskId)
    230          {
    231              Menu_handle_msg(MSG_POWERON_ANIM, NULL, 0);
    232          
    233              /* Initialize the task id */
    234              MP_TaskId = taskId;
    235          
    236              /* initialize MAC features */
    237              MAC_Init();
    238              MAC_InitDevice();
    239          
    240              /* Reset the MAC */
    241              MAC_MlmeResetReq(TRUE);
    242          
    243              /*inittial variables */
    244              MP_DevInfo.Channel = 0x0B;
    245              MP_DevInfo.CoordPanID = 0xFFFF;
    246              MP_DevInfo.armid = APP_INVALIDARMADDR;
    247              MP_DevInfo.currentRssi = MP_MIN_RSSI;
    248              MP_DevInfo.DesireCoordPanID = 0xFFFF;
    249          
    250              MP_AudioInfo.peernmbr = 0;
    251              MP_AudioInfo.seqnum = 0;
    252              MP_AudioInfo.cmdseqnum = 0;
    253          
    254              MP_NwkInfo.nwkState = NWK_DETAIL_INIT;
    255          
    256              MP_ReadR_or_DInfo();
    257              MP_ReadExtAddr();
    258              MP_DeviceStartup();
    259          
    260              //vehicle_rssi_data.app_tof_head.msgtype = 42;
    261              //vehicle_rssi_data.app_tof_head.protocoltype = APP_PROTOCOL_TYPE_CARD;
    262              vehicle_rssi_data.u16station_addr = MP_DevInfo.nmbr;
    263              vehicle_rssi_data.u16seqnum = 1;
    264          
    265          #if(defined WATCHDOG) && (WATCHDOG==TRUE)
    266              // StartWatchDog(DOGTIMER_INTERVAL_1S);
    267              MP_set_event(MP_TaskId, MP_FEEDDOG_EVENT);
    268          #endif
    269          
    270              /* Audio */
    271              /* DO NOT put it in HalDriverInit, because it needs memalloc */
    272          #if (defined HAL_AUDIO) && (HAL_AUDIO == TRUE)
    273              HalAudioInit();
    274          #endif
    275          
    276              init_uart(HAL_UART_PORT_0,0x08);  //115200
    277          
    278          
    279              MP_RFState = MP_RF_OK;
    280              //MP_start_timerEx(MP_TaskId, MP_UART_READ_EVENT, 50);
    281              MP_start_timerEx(MP_TaskId,MP_REPORT_VEHICLE_RSSI_EVENT,50);
    282          }
    283          
    284          uint8 Mp_num_isequal(const app_termNbr_t *p1, const app_termNbr_t *p2)
    285          {
    286          	unsigned int i;
    287              unsigned int j;
    288          
    289                 for(i=0; i<APP_NMBRDIGIT; i++)
    290                 {
    291                      for(j=0; j<2; j++)
    292                      {
    293                          uint8 num1,num2;
    294                          if(j==0)
    295                          {
    296                              num1 = p1->nbr[i] & 0xFF;
    297                              num2 = p2->nbr[i] & 0xFF;
    298                          }
    299                          else
    300                          {
    301                              num1 = p1->nbr[i]>>4 & 0xFF;
    302                              num2 = p2->nbr[i]>>4 & 0xFF;
    303                          }
    304          
    305                          if(num1 == 0xFF || num2 == 0xFF)  // one end
    306                          {
    307                              if(num1 == num2)
    308                              {
    309                                  return 1;
    310                              }
    311                              else
    312                              {
    313                                  return 0;
    314                              }
    315                          }
    316                          else
    317                          {
    318                              if((num1 != num2) && ((num1+0x10) != num2)&& ((num1+0x01) != num2))
    319                              {
    320                                  return 0;
    321                              }
    322                          }
    323                      }
    324                 }
    325                  return 0;
    326          }
    327          
    328          void MP_to_release_vesion()
    329          {
    330              uint8 Param=0xff;
    331              osal_nv_write(MP_NV_R_OR_D_ITEM, 0, sizeof(uint8), &Param);
    332              Menu_rf_debug=false;
    333              Rssi_information=false;
    334              Packge_information=false;
    335          }
    336          
    337          void MP_ReadR_or_DInfo()
    338          {
    339              //MP_SetR_or_DInfo();
    340              uint8 Param,pos;
    341          
    342              Param = osal_nv_item_init(MP_NV_R_OR_D_ITEM, sizeof(uint8), NULL);
    343              if(Param == NV_ITEM_UNINIT)
    344              {
    345                  pos = 0xff;
    346                  osal_nv_write(MP_NV_R_OR_D_ITEM,0, sizeof(uint8), &pos);
    347              }
    348          
    349              osal_nv_read(MP_NV_R_OR_D_ITEM, 0, sizeof(uint8), &Param);//* (storeParam_t *)(MP_R_or_D_INFO_ADDR);
    350              if(!Param)
    351              {
    352                  Menu_rf_debug=true;
    353                  Rssi_information=true;
    354                  Packge_information=true;
    355              }
    356              else
    357              {
    358                  Menu_rf_debug=false;
    359                  Rssi_information=false;
    360                  Packge_information=false;
    361              }
    362          }
    363          void MP_SetR_or_DInfo()
    364          {
    365              //storeParam_t Param=*(storeParam_t *)(MP_R_or_D_INFO_ADDR);
    366              uint8 Param;
    367              osal_nv_read(MP_NV_R_OR_D_ITEM, 0, sizeof(uint8), &Param);
    368              if(!Param)
    369                  Param=0xff;
    370              else Param=0x0;
    371              osal_nv_write(MP_NV_R_OR_D_ITEM, 0, sizeof(uint8), &Param);
    372          }
    373          /**************************************************************************************************
    374          *
    375          * @fn          MP_ProcessEvent
    376          *
    377          * @brief       This routine handles events
    378          *
    379          * @param       taskId - ID of the application task when it registered with the OSAL
    380          *              events - Events for this task
    381          *
    382          * @return      16bit - Unprocessed events
    383          *
    384          **************************************************************************************************/
    385          uint16 MP_ProcessEvent(uint8 taskId, uint16 events)
    386          {
    387          #if(defined WATCHDOG) && (WATCHDOG==TRUE)
    388              if(events & MP_FEEDDOG_EVENT)
    389              {
    390                  if(NO_TIMER_AVAIL == osal_start_timerEx(MP_TaskId, MP_FEEDDOG_EVENT, 300))
    391                  {
    392                      SystemReset();
    393                  }
    394                  FeedWatchDog();
    395                  return events ^ MP_FEEDDOG_EVENT;
    396              }
    397          #endif
    398          
    399              if(events & SYS_EVENT_MSG)
    400              {
    401                  uint8 *pMsg;
    402                  while((pMsg = osal_msg_receive(MP_TaskId)) != NULL)
    403                  {
    404                      macCbackEvent_t *pData = (macCbackEvent_t *)pMsg;
    405                      switch(*pMsg)
    406                      {
    407                      case MAC_MLME_COMM_STATUS_IND:
    408                          break;
    409          
    410                      case MAC_MCPS_DATA_CNF:
    411                          pData = (macCbackEvent_t *) pMsg;
    412                          mac_msg_deallocate((uint8 **)&pData->dataCnf.pDataReq);
    413                          break;
    414          
    415                      case MAC_MCPS_DATA_IND:
    416                      {
    417                          pData = (macCbackEvent_t *)pMsg;
    418                          MP_ParseAppFrame(pData->dataInd.msdu, pData->dataInd.mac.srcPanId, pData->dataInd.mac.srcAddr.addr.shortAddr, pData->dataInd.mac.rssi);
    419                          break;
    420                      }
    421                      }
    422          
    423                      /* Deallocate */
    424                      //MAC_MCPS_DATA_CNF is handled in hal_drivers
    425                      mac_msg_deallocate((uint8 **)&pMsg);
    426                  }
    427          
    428                  return events ^ SYS_EVENT_MSG;
    429              }
    430              /* resend dialup command */
    431              if(events & MP_DIALUP_RETRY_EVENT)
    432              {
    433                  /* continues to send dial up until found, accepted, or start voice  */
    434                  if(MP_AudioInfo.peernmbr != MP_SHORT_INVALIDNMMBR
    435                          && (ON_CALLING() || ON_CALLINGWAIT()))
    436                  {
    437                      MP_AudioInfo.retrying_bitmap |= MP_DIALUP_RETRY_BIT;
    438                      MP_SendCmd(MP_UP_DIALUP, &MP_AudioInfo.peer_termnbr, MP_AudioInfo.cmdseqnum);
    439                      MP_start_timerEx(MP_TaskId, MP_DIALUP_RETRY_EVENT, MP_SIGNAL_RETRY_TIME);
    440                  }
    441                  else
    442                  {
    443                      MP_AudioInfo.retrying_bitmap &= ~MP_DIALUP_RETRY_BIT;
    444                  }
    445                  return (events ^ MP_DIALUP_RETRY_EVENT);
    446              }
    447          
    448              /* resend accept command */
    449              if(events & MP_ACCEPT_RETRY_EVENT)
    450              {
    451                  if(++MP_AudioInfo.accept_cnt < 3 && MP_AudioInfo.peernmbr != MP_SHORT_INVALIDNMMBR)
    452                  {
    453                      MP_SendCmd(MP_UP_ACCEPT, &MP_AudioInfo.peer_termnbr, MP_AudioInfo.cmdseqnum);
    454                      MP_start_timerEx(MP_TaskId, MP_ACCEPT_RETRY_EVENT, 200);
    455                      MP_AudioInfo.retrying_bitmap |= MP_ACCEPT_RETRY_BIT;
    456                  }
    457                  else
    458                  {
    459                      MP_AudioInfo.accept_cnt = 0;
    460                      MP_AudioInfo.retrying_bitmap &= ~MP_ACCEPT_RETRY_BIT;
    461                  }
    462                  return (events ^ MP_ACCEPT_RETRY_EVENT);
    463              }
    464          
    465              /* resend close command */
    466              if(events & MP_CLOSE_RETRY_EVENT)
    467              {
    468                  if(++MP_AudioInfo.close_cnt < 3 && MP_AudioInfo.peernmbr != MP_SHORT_INVALIDNMMBR)
    469                  {
    470                      MP_SendCmd(MP_UP_CLOSE, &MP_AudioInfo.peer_termnbr, MP_AudioInfo.cmdseqnum);
    471                      MP_start_timerEx(MP_TaskId, MP_CLOSE_RETRY_EVENT, 100);
    472                      MP_AudioInfo.retrying_bitmap |= MP_CLOSE_RETRY_BIT;
    473                  }
    474                  else
    475                  {
    476                      MP_AudioInfo.close_cnt = 0;
    477                      MP_AudioInfo.retrying_bitmap &= ~MP_CLOSE_RETRY_BIT;
    478                  }
    479                  return (events ^ MP_CLOSE_RETRY_EVENT);
    480              }
    481          
    482              if(events & MP_PROBENWK_EVENT)
    483              {
    484                  if(++MP_RejoinTimes > MP_REJOINTIMES)
    485                  {
    486                      MP_RejoinTimes = 0;
    487          
    488                      MP_NwkInfo.nwkState = NWK_DETAIL_INIT;
    489                      MP_DevInfo.CoordPanID = 0xFFFF;
    490                      MP_DevInfo.armid = APP_INVALIDARMADDR;
    491                      MP_DevInfo.currentRssi = MP_MIN_RSSI;
    492          
    493                      if(ON_AUDIO()) /* if on audio, jump to searching nwk */
    494                      {
    495                          HalAudioClose();
    496                          Menu_handle_msg(MSG_INIT_NWK, NULL, 0);
    497                          HAL_AlarmSet(MP_ALARM_INITNWK, MP_INIT_NWK_TIMEOUT);
    498                      }
    499                      else     /* Update the loggo to NO NETWORK when on Main */
    500                      {
    501                          Menu_RefreshNwkDisp();
    502                      }
    503                  }
    504                  else
    505                  {
    506                      if(MP_RejoinTimes > MP_REJOINTIMES - 1)
    507                      {
    508                          Menu_UpdateSignal(0);
    509                      }
    510                      MP_start_timerEx(MP_TaskId, MP_PROBENWK_EVENT, MP_NWKTOLERANCE_TIME * 1000);
    511                  }
    512                  return events ^ MP_PROBENWK_EVENT;
    513              }
    514          
    515              if(events & MP_STOP_AUDIO_EVENT)
    516              {
    517                  //if(ON_AUDIO())
    518                  if(AudioIsEnabled())
    519                  {
    520                      SystemReset();
    521                      //MP_SetPeerNum(NULL);
    522                      //MP_ResetAudio();
    523                      //Menu_handle_msg(MSG_INIT_MAIN, 0, 0);
    524                  }
    525                  return events ^ MP_STOP_AUDIO_EVENT;
    526          
    527              }
    528              if(events & MP_SCAN_AUDIO_EVENT)
    529              {
    530                  /* if I did not receive audio in 5 seconds, may be last station is losted, start a scan immediately */
    531                  if(ON_AUDIO())
    532                  {
    533                      MP_DevInfo.currentRssi = -120 ;
    534                      MP_DevInfo.hascoordlink = false;
    535                      MP_start_timerEx(MP_Function_TaskID, MP_FUNC_PERIODIC_SCAN_EVENT, 5);
    536                  }
    537                  return events ^ MP_SCAN_AUDIO_EVENT;
    538              }
    539          
    540              if(events & MP_UART_READ_EVENT)
    541              {
    542                  //if(IS_IDLE() || ON_WAKE())
    543                  uint8 i;
    544                  uint8 data;
    545          
    546                  extern bool     keyactive;
    547                  extern bool     lastkeyactive;
    548          
    549                  uartlen = HalUARTRead(HAL_UART_PORT_0,uartReadBuf,127);
    550                  if(uartlen > 0)
    551                  {
    552                      for(i=0; i<uartlen; i++)
    553                      {
    554                          data = uartReadBuf[i];
    555                          switch(uart_recv_state)
    556                          {
    557                          case UARTSTATE_PREAMBLE_Y:
    558                              if(data == 'Y')
    559                                  uart_recv_state = UARTSTATE_PREAMBLE_I;
    560                              break;
    561          
    562                          case UARTSTATE_PREAMBLE_I:
    563                              if(data == 'I')
    564                                  uart_recv_state = UARTSTATE_PREAMBLE_R;
    565                              else
    566                                  uart_recv_state = UARTSTATE_PREAMBLE_Y;
    567                              break;
    568          
    569                          case UARTSTATE_PREAMBLE_R:
    570                              if(data == 'R')
    571                                  uart_recv_state = UARTSTATE_DATA;
    572                              else
    573                                  uart_recv_state = UARTSTATE_PREAMBLE_Y;
    574                              break;
    575          
    576                          case UARTSTATE_DATA:
    577          
    578                              if(data == 6)
    579                              {
    580                                  //extern bool     keyactive;
    581                                  //extern bool     lastkeyactive;
    582                                  keyactive = TRUE;
    583                                  lastkeyactive = TRUE;
    584                              }
    585                              else if(data == 7)
    586                              {
    587                                  //extern bool     keyactive;
    588                                  //extern bool     lastkeyactive;
    589                                  keyactive = FALSE;
    590                                  lastkeyactive = FALSE;
    591                              }
    592                              else
    593                              {
    594                                  if(IS_IDLE() || ON_WAKE())
    595                                  {
    596                                      if(data == 1 && (!AudioIsEnabled()))
    597                                      {
    598                                          //osal_stop_timerEx(MP_TaskId, MP_AUDIO_PROTECT_EVENT);
    599                                          //osal_clear_event(MP_TaskId, MP_AUDIO_PROTECT_EVENT);
    600                                          //MP_start_timerEx(MP_TaskId, MP_AUDIO_PROTECT_EVENT, 8000);
    601                                          
    602                                          MP_ResetAudioStatus(MP_STOP_AUDIO_TIMEOUT);//FIXME:To avoid the other side not start normally.
    603                                          card_status = CARD_STATUS_HELP;
    604                                          //HalAudioClose();
    605                                          MP_ResetAudio();
    606                                          MP_StopSignalRetrys();
    607                                          
    608                                          
    609                                          Hal_StartVoiceBell(VOICEBELL_HELP);
    610                                      }
    611                                      else if(data == 2 && (!AudioIsEnabled()))
    612                                      {
    613                                          MP_ResetAudioStatus(MP_STOP_AUDIO_TIMEOUT);
    614                                          MP_ResetAudio();
    615                                          MP_StopSignalRetrys();
    616                                          Hal_StartVoiceBell(VOICEBELL_RETREAT);
    617                                      }
    618                                      else if(data == 4 && (!AudioIsEnabled()))   //超速提醒
    619                                      {
    620                                          MP_ResetAudioStatus(MP_STOP_AUDIO_TIMEOUT);
    621                                          MP_ResetAudio();
    622                                          MP_StopSignalRetrys();
    623                                          Hal_StartVoiceBell(VOICEBELL_SPEED);
    624                                      }
    625                                      else if(data == 5 && card_status == CARD_STATUS_HELP)   //求救已发送
    626                                      {
    627                                          MP_ResetAudioStatus(MP_STOP_AUDIO_TIMEOUT);
    628                                          card_status = CARD_STATUS_NORMAL;
    629                                          MP_ResetAudio();
    630                                          MP_StopSignalRetrys();
    631                                          Hal_StartVoiceBell(VOICEBELL_HELP_ACK);
    632                                      }
    633                                      else if(data == 8 && (!AudioIsEnabled()))   //UART_CMD_SLOW_DOWM
    634                                      {
    635                                          MP_ResetAudioStatus(MP_STOP_AUDIO_TIMEOUT);
    636                                          MP_ResetAudio();
    637                                          MP_StopSignalRetrys();
    638                                          Hal_StartVoiceBell(VOICEBELL_SLOW_DOWM);
    639                                      }
    640                                      else if(data == 9 && (!AudioIsEnabled()))   //UART_CMD_AVOID
    641                                      {
    642                                          MP_ResetAudioStatus(MP_STOP_AUDIO_TIMEOUT);
    643                                          MP_ResetAudio();
    644                                          MP_StopSignalRetrys();
    645                                          Hal_StartVoiceBell(VOICEBELL_AVOID);
    646                                      }
    647                                      else if(data == 10 && (!AudioIsEnabled()))   //UART_CMD_GIVE_WAY
    648                                      {
    649                                          MP_ResetAudioStatus(MP_STOP_AUDIO_TIMEOUT);
    650                                          MP_ResetAudio();
    651                                          MP_StopSignalRetrys();
    652                                          Hal_StartVoiceBell(VOICEBELL_GIVE_WAY);
    653                                      }
    654                                  }
    655                              }
    656                              uart_recv_state = UARTSTATE_PREAMBLE_Y;
    657                              break;
    658                          }
    659                      }
    660                  }
    661          
    662                  //if(keyactive)
    663                  //MP_start_timerEx(MP_TaskId, MP_UART_READ_EVENT, 500);
    664                  return events ^ MP_UART_READ_EVENT;
    665              }
    666          
    667              /*if(MP_KEYBOARD_STATE_EVENT)
    668              {
    669                  //extern bool     lastkeyactive;
    670                  //Hal_SetKeyActive(lastkeyactive);
    671                  return events ^ MP_KEYBOARD_STATE_EVENT;
    672              }*/
    673          
    674              if(MP_REPORT_VEHICLE_RSSI_EVENT)
    675              {
    676                  ReportVehicleCardRssi();
    677                  MP_start_timerEx(MP_TaskId, MP_REPORT_VEHICLE_RSSI_EVENT,1000);
    678                  return events ^ MP_REPORT_VEHICLE_RSSI_EVENT;
    679              }
    680              return 0;
    681          
    682          //#ifdef PACKAGE_INFORMATION
    683              if(Packge_information==true)
    684              {
    685                  if(events & MP_PACKAGE_INFORM_EVENT)
    686                  {
    687                      Menu_UpdatePackage(MP_packet_info.recv_cnt, MP_packet_info.err_cnt);
    688                      if(NO_TIMER_AVAIL == osal_start_timerEx(MP_TaskId, MP_PACKAGE_INFORM_EVENT, 1000))
    689                      {
    690                          SystemReset();
    691                      }
    692                      return events ^ MP_PACKAGE_INFORM_EVENT;
    693                  }
    694              }
    695          //#endif
    696          #ifdef CFG_STATION_CHECK
    697              if(Menu_rf_debug)
    698              {
    699                  if(events & MP_STATION_CHECK_EVENT)
    700                  {
    701                      MP_Station_Signal_Update();
    702                      return events ^ MP_STATION_CHECK_EVENT;
    703                  }
    704              }
    705          #endif
    706              return 0;
    707          }
    708          
    709          /**************************************************************************************************
    710          *
    711          * @fn          init_uart
    712          *
    713          * @brief       init uart
    714          *
    715          * @param       UART_PORT - number of  uart port
    716          *              baudRate -
    717          *
    718          * @return      void
    719          *
    720          **************************************************************************************************/
    721          static void init_uart(uint8  uartPort , uint8 baudRate)
    722          {
    723              halUARTCfg_t uartConfig;
    724          
    725              uartConfig.configured           = true;
    726              uartConfig.baudRate             = baudRate;
    727              uartConfig.flowControl          = false;
    728              uartConfig.flowControlThreshold = 48;
    729              uartConfig.rx.maxBufSize        = 128;
    730              uartConfig.tx.maxBufSize        = 128;
    731              uartConfig.idleTimeout          = 6;
    732              uartConfig.intEnable            = true;
    733              uartConfig.callBackFunc         = NULL;
    734          
    735              /*two ports. one for backup*/
    736              HalUARTOpen(uartPort, &uartConfig);
    737          }
    738          
    739          /**************************************************************************************************
    740          *
    741          * @fn          MAC_CbackEvent
    742          *
    743          * @brief       This callback function sends MAC events to the application.
    744          *              The application must implement this function.  A typical
    745          *              implementation of this function would allocate an OSAL message,
    746          *              copy the event parameters to the message, and send the message
    747          *              to the application's OSAL event handler.  This function may be
    748          *              executed from task or interrupt context and therefore must
    749          *              be reentrant.
    750          *
    751          * @param       pData - Pointer to parameters structure.
    752          *
    753          * @return      None.
    754          *
    755          **************************************************************************************************/
    756          void MAC_CbackEvent(macCbackEvent_t *pData)
    757          {
    758          
    759              macCbackEvent_t *pMsg = NULL;
    760          
    761              uint8 len = MP_cbackSizeTable[pData->hdr.event];
    762          
    763              switch(pData->hdr.event)
    764              {
    765              case MAC_MLME_BEACON_NOTIFY_IND:
    766          
    767                  len += sizeof(macPanDesc_t) + pData->beaconNotifyInd.sduLength +
    768                         MAC_PEND_FIELDS_LEN(pData->beaconNotifyInd.pendAddrSpec);
    769                  if((pMsg = (macCbackEvent_t *) osal_msg_allocate(len)) != NULL)
    770                  {
    771                      /* Copy data over and pass them up */
    772                      osal_memcpy(pMsg, pData, sizeof(macMlmeBeaconNotifyInd_t));
    773                      pMsg->beaconNotifyInd.pPanDesc = (macPanDesc_t *)((uint8 *) pMsg + sizeof(macMlmeBeaconNotifyInd_t));
    774                      osal_memcpy(pMsg->beaconNotifyInd.pPanDesc, pData->beaconNotifyInd.pPanDesc, sizeof(macPanDesc_t));
    775                      pMsg->beaconNotifyInd.pSdu = (uint8 *)(pMsg->beaconNotifyInd.pPanDesc + 1);
    776                      osal_memcpy(pMsg->beaconNotifyInd.pSdu, pData->beaconNotifyInd.pSdu, pData->beaconNotifyInd.sduLength);
    777                  }
    778                  break;
    779          
    780              case MAC_MCPS_DATA_IND:
    781                  pMsg = pData;
    782                  break;
    783          
    784              default:
    785                  if((pMsg = (macCbackEvent_t *) osal_msg_allocate(len)) != NULL)
    786                  {
    787                      osal_memcpy(pMsg, pData, len);
    788                  }
    789                  break;
    790              }
    791          
    792              if(pMsg != NULL)
    793              {
    794                  osal_msg_send(MP_TaskId, (uint8 *) pMsg);
    795              }
    796          }
    797          
    798          /**************************************************************************************************
    799          *
    800          * @fn      MAC_CbackCheckPending
    801          *
    802          * @brief   Returns the number of indirect messages pending in the application
    803          *
    804          * @param   None
    805          *
    806          * @return  Number of indirect messages in the application
    807          *
    808          **************************************************************************************************/
    809          uint8 MAC_CbackCheckPending(void)
    810          {
    811              return (0);
    812          }
    813          
    814          /**************************************************************************************************
    815          *
    816          * @fn      MP_DeviceStartup()
    817          *
    818          * @brief   Update the timer per tick
    819          *
    820          * @param   beaconEnable: TRUE/FALSE
    821          *
    822          * @return  None
    823          *
    824          **************************************************************************************************/
    825          void MP_DeviceStartup()
    826          {
    827              /* Setup exitAddr */
    828              MAC_MlmeSetReq(MAC_EXTENDED_ADDRESS, &MP_DevInfo.ExitAddr);
    829          
    830              /* set channel */
    831              MAC_MlmeSetReq(MAC_LOGICAL_CHANNEL, &MP_DevInfo.Channel);
    832          
    833              /* Setup shortAddr */
    834              uint16 MobilePanid =  MP_DevInfo.nmbr;
    835              //MAC_MlmeSetReq(MAC_SHORT_ADDRESS, &ShortAddr);
    836              MAC_MlmeSetReq(MAC_PAN_ID, &MobilePanid);
    837          
    838              /* Setup PAN ID */
    839              uint16 MobileShortAddr = 0x0000;
    840              //MAC_MlmeSetReq(MAC_PAN_ID, &MobilePanID);
    841              MAC_MlmeSetReq(MAC_SHORT_ADDRESS, &MobileShortAddr);
    842          
    843              /* This device is setup for Direct Message */
    844              MAC_MlmeSetReq(MAC_RX_ON_WHEN_IDLE, &MP_MACTrue);
    845          
    846              /* Setup Coordinator short address */
    847              uint16 tmp = 0;
    848              MAC_MlmeSetReq(MAC_COORD_SHORT_ADDRESS, &tmp);
    849          
    850              uint8 SuperFrameOrder = 15;
    851              MAC_MlmeSetReq(MAC_SUPERFRAME_ORDER, &SuperFrameOrder);
    852          
    853              uint8 BeaconOrder = 15;
    854              MAC_MlmeSetReq(MAC_BEACON_ORDER, &BeaconOrder);
    855          
    856              /* change CCA param */
    857              uint8 maxFrameRetries = 4;
    858              MAC_MlmeSetReq(MAC_MAX_FRAME_RETRIES, &maxFrameRetries);
    859          
    860              uint8 maxCsmaBackoff  = 5;
    861              MAC_MlmeSetReq(MAC_MAX_CSMA_BACKOFFS, &maxCsmaBackoff);
    862          
    863              uint8 minBe = 4;
    864              MAC_MlmeSetReq(MAC_MIN_BE, &minBe);
    865          
    866              uint8 maxBe = 6;
    867              MAC_MlmeSetReq(MAC_MAX_BE, &maxBe);
    868          
    869              /* set associated */
    870              bool associated = true;
    871              MAC_MlmeSetReq(MAC_ASSOCIATED_PAN_COORD, &associated);
    872          
    873          }
    874          
    875          void SysUtil_vConvertEndian(void* pvData, uint8 u8Len)
    876          {
    877              int i;
    878              uint8* pu8Data = (uint8*) pvData;
    879              for(i=0;i<u8Len/2;i++)
    880              {
    881                  uint8 tmp;
    882                  tmp= pu8Data[i];
    883                  pu8Data[i] = pu8Data[u8Len-i-1];
    884                  pu8Data[u8Len-i-1] = tmp;
    885              }
    886          }
    887          
    888          
    889          /**************************************************************************************************
    890          *
    891          * @fn      ParseAppFrame(const afIncomingMSGPacket_t* MSGpkt)
    892          *
    893          * @brief   Parse AppData. Parse the app data from radio.
    894          *
    895          * @param   MSGpkt -the incoming msg.
    896          *
    897          * @return  status.
    898          *
    899          **************************************************************************************************/
    900          byte MP_ParseAppFrame(const sData_t data, uint16 panid, uint16 shortAddr, int8 rssi)
    901          {
    902              app_header_t *pHeader  = (app_header_t *)(data.p);
    903              uint8 *pPayload = (uint8 *)(pHeader + 1);
    904          
    905          #if 0
    906              if(pHeader->protocoltype != APP_PROTOCOL_TYPE_MOBILE  || data.len < sizeof(app_header_t) + pHeader->len)
    907              {
    908                  //if(pHeader->protocoltype == APP_PROTOCOL_TYPE_CARD && ((IS_IDLE() || ON_WAKE())))
    909                  if(pHeader->protocoltype == APP_PROTOCOL_TYPE_CARD)
    910                  {
    911                      if(pHeader->msgtype == 0x05) // rssi
    912                      {
    913                          RfTofWrapper_tu* psAppPkt = (RfTofWrapper_tu*)(data.p);
    914          
    915                          vehicle_rssi_data.vehicle_rssi[u16RssiNum].u16ShortAddr = shortAddr;
    916                          vehicle_rssi_data.vehicle_rssi[u16RssiNum].i8Rssi = rssi;
    917                          vehicle_rssi_data.vehicle_rssi[u16RssiNum].u8Reserved = 0;
    918                          vehicle_rssi_data.vehicle_rssi[u16RssiNum].uu16SeqNum = psAppPkt->rf_tof_card_data.u16SeqNum;
    919                          SysUtil_vConvertEndian(&vehicle_rssi_data.vehicle_rssi[u16RssiNum].uu16SeqNum,sizeof(uint16));
    920          
    921                          u16RssiNum++;
    922          
    923                          if(10 == u16RssiNum)
    924                          {
    925                              ReportVehicleCardRssi();
    926                              /*vehicle_rssi_data.u16seqnum++;
    927                              MP_SendTunnelToAllCoord((uint8 *)(&vehicle_rssi_data),u16RssiNum*sizeof(vehicle_rssi_ts)+4,42,true);
    928                              u16RssiNum = 0;*/
    929                          }
    930                          return ZSUCCESS;
    931                      }
    932                  }
    933                  else
    934                      return FAILURE;
    935          
    936              }
    937          #endif
    938              switch(pHeader->msgtype)
    939              {
    940              case MP_VOICE:
    941              {
    942                  app_mpVoice_t *p = (app_mpVoice_t *)pPayload;
    943                  if(data.len >= sizeof(app_header_t) + sizeof(app_mpVoice_t) + p->len)
    944                  {
    945                      MP_ParseVoice(p, rssi);
    946                  }
    947                  break;
    948              }
    949              case MP_CMD_DOWN:
    950              {
    951                  if(data.len >= sizeof(app_header_t) + sizeof(app_mpCmd_t))
    952                  {
    953                      MP_ParseCmd((app_mpCmd_t *)pPayload);
    954                  }
    955                  break;
    956              }
    957              /*case MP_SMS:
    958              {
    959                  app_mpSMS_t *p = (app_mpSMS_t *)pPayload;
    960                  if(data.len >= sizeof(app_header_t) + sizeof(app_mpSMS_t) + p->len
    961                          &&   p->smstype == APP_MP_SMSTYPE_CONTENT &&  num_isequal(&p->dstnbr, &MP_DevInfo.termNbr))
    962                  {
    963                      MP_ParseSms(p);
    964                  }
    965                  break;
    966              }*/
    967              case MP_SCAN:
    968              {
    969                  mp_Scan_t *p = (mp_Scan_t *)pPayload;
    970                  if(data.len >= sizeof(app_header_t) + sizeof(mp_Scan_t)
    971                          &&  MP_ScanInfo.isscaning && p->scantype == APP_SCAN_TYPE_ACK && shortAddr == 0)
    972                  {
    973                      MP_CellSwitchCondition(panid, rssi);
    974                      //Menu_handle_msg(MSG_INIT_MAIN, NULL, 0);
    975                  }
    976                  break;
    977              }
    978              case MP_JOIN_NOTIFY:
    979              {
    980                  app_mpJoinNwk_t *p = (app_mpJoinNwk_t *)pPayload;
    981                  if(data.len >=  sizeof(app_header_t) + sizeof(app_mpJoinNwk_t)
    982                          && p->hdr.dstaddr == MP_DevInfo.nmbr)
    983                  {
    984                      MP_ParseJoin(p, panid, rssi);
    985                  }
    986                  break;
    987              }
    988              case MP_TIME:
    989              {
    990                  Date_t CurrentDate = GetDate();
    991                  app_mpTime_t *p = (app_mpTime_t *)pPayload;
    992                  if(data.len ==  sizeof(app_header_t) + sizeof(app_mpTime_t)
    993                          //&& CurrentDate.year == TIME_INIT_YEAR
    994                    )
    995                  {
    996                      MP_ParseTime(p);
    997                  }
    998                  break;
    999              }
   1000          
   1001              case MP_POLL:
   1002              {
   1003                  app_mpPoll_t *p = (app_mpPoll_t *)pPayload;
   1004          
   1005                  if(data.len >=  sizeof(app_header_t) + sizeof(app_mpPoll_t)
   1006                          && p->polltype == APP_MPPOLL_TYPE_ACK
   1007                          && panid == MP_DevInfo.CoordPanID && shortAddr == 0
   1008                          && p->hdr.dstaddr == MP_DevInfo.nmbr)
   1009                  {
   1010                      MP_ParsePoll(p, rssi);
   1011                  }
   1012                  break;
   1013              }
   1014              default:
   1015                  break;
   1016              }
   1017              return ZSUCCESS;
   1018          }
   1019          
   1020          void MP_ParseVoice(const app_mpVoice_t *pVoice, int8 rssi)
   1021          {
   1022              /* if the voice is not mine or the peer is not my peer  */
   1023              if(MP_DevInfo.nmbr != pVoice->hdr.dstaddr || (pVoice->hdr.srcaddr != MP_AudioInfo.peernmbr
   1024                      &&(MP_AudioInfo.peernmbr != MP_SHORT_GATEWAYNMBR)))
   1025              {
   1026                  return ;
   1027              }
   1028          
   1029              /*save the peer voice timetick */
   1030              MP_AudioInfo.peer_tick = osal_GetSystemClock();
   1031          
   1032              /*save coord rssi */
   1033              MP_DevInfo.currentRssi = rssi;
   1034              MP_DevInfo.hascoordlink = true;
   1035          
   1036          //#ifdef PACKAGE_INFORMATION
   1037              if(Packge_information==true)
   1038              {
   1039                  uint16 diff = pVoice->seqnum - MP_AudioInfo.seqnum;
   1040                  if(diff == 0 || diff > 20)
   1041                  {
   1042                      diff = 1;
   1043                  }
   1044                  MP_packet_info.err_cnt += diff - 1;
   1045                  MP_packet_info.recv_cnt++;
   1046              }
   1047          //#endif
   1048          
   1049              //filter duplicated frames.
   1050              if(pVoice->seqnum > MP_AudioInfo.seqnum
   1051                      || (pVoice->seqnum != MP_AudioInfo.seqnum &&  MP_AudioInfo.seqnum > 245 && pVoice->seqnum < 10))
   1052              {
   1053                  if(MP_SilenceSignCheck(pVoice->silencemap, pVoice->len) == false)
   1054                  {
   1055                      return ;
   1056                  }
   1057          
   1058                  /* if source is changed for continues 5 times, changeed peer number */
   1059                  static uint8 src_change_cnt;
   1060                  if(pVoice->hdr.srcaddr  == MP_AudioInfo.peernmbr)
   1061                  {
   1062                      src_change_cnt = 0;
   1063                  }
   1064                  else
   1065                  {
   1066                      if(src_change_cnt++ >=5)
   1067                      {
   1068                          src_change_cnt = 0;
   1069                          app_termNbr_t termNbr;
   1070                          char savenbr[20];
   1071                          if(!MP_AudioInfo.IsTalkWithGateWay)  //only change number display when doing inside call
   1072                          {
   1073                              _itoa(pVoice->hdr.srcaddr, savenbr, 10);
   1074                              num_str2term(&termNbr,savenbr);
   1075                              MP_SetPeerNum(&termNbr);
   1076                              Menu_RefreshNwkDisp();
   1077                          }
   1078                      }
   1079                  }
   1080          
   1081          
   1082                  MP_AudioInfo.seqnum = pVoice->seqnum;
   1083          
   1084                  uint8 num = 0;
   1085                  uint8 *pvoicedata = (uint8 *)(pVoice + 1);
   1086          
   1087                  for(uint8 i = 0; i < VOICE_IDX_THRESHOLD; i++)
   1088                  {
   1089                      if((pVoice->silencemap >> i) & 0x01 == 1)
   1090                      {
   1091                          memcpy(MP_VoiceBuf + i * VOICE_PER_RAW_DATA_LEN, pvoicedata + num * VOICE_PER_RAW_DATA_LEN, VOICE_PER_RAW_DATA_LEN);
   1092                          num++;
   1093                      }
   1094                      else
   1095                      {
   1096          
   1097                          memcpy(MP_VoiceBuf + i * VOICE_PER_RAW_DATA_LEN, SilenceFrame, VOICE_PER_RAW_DATA_LEN);
   1098          
   1099                      }
   1100                  }
   1101              }
   1102          
   1103              //FillAudioBufferFlush(MP_VoiceBuf, VOICE_IDX_THRESHOLD * VOICE_PER_RAW_DATA_LEN);
   1104              FillAudioBuffer((uint8 *)MP_VoiceBuf, VOICE_IDX_THRESHOLD * VOICE_PER_RAW_DATA_LEN);
   1105              MP_RejoinTimes = 0;
   1106              osal_start_timerEx(MP_TaskId, MP_PROBENWK_EVENT, MP_NWKTOLERANCE_TIME * 1000);
   1107          
   1108          
   1109              //Handle exception.
   1110              if(IS_IDLE() || ON_WAKE())
   1111                  /*
   1112                  *hangup party push down hangup key, send CMD_UP_CLOSE signal and return to idle status,
   1113                  *but ARM don't receive CMD_UP_CLOSE signal, and relay voice pkt again,
   1114                  *so hangup party need to send CMD_UP_CLOSE signal again.
   1115                  */
   1116              {
   1117                  MP_SendCmd(MP_UP_CLOSE, &MP_AudioInfo.peer_termnbr, MP_AudioInfo.cmdseqnum);
   1118              }
   1119              else if(ON_CALLING() || ON_CALLINGWAIT() || ON_FOUND())
   1120                  /*Calling party loses CMD_DOWN_ACCEPT signal, so it needs to start audio and switch to audio status
   1121                  *until receving voice pkt.
   1122                  */
   1123              {
   1124                  MP_AudioInfo.seqnum = 0;//need reset frameblk.
   1125                  MP_StartTalk();
   1126                  Menu_handle_msg(MSG_DIALING_SUCCESS, NULL, 0);
   1127              }
   1128          
   1129              if(signal_update_count)signal_update_count--;
   1130              else
   1131              {
   1132                  signal_update_count=10;
   1133                  Menu_UpdateSignal(MP_Rssi2Level(rssi));
   1134              }
   1135          
   1136              /*FIXME:To avoid ambe of the other side not start absolutely, so close myself.
   1137              */
   1138              MP_ResetAudioStatus(MP_STOP_AUDIO_TIMEOUT);
   1139          
   1140          }
   1141          
   1142          void MP_ParseCmd(const app_mpCmd_t *pCmd)
   1143          {
   1144              /* clear package informations */
   1145          //#ifdef PACKAGE_INFORMATION
   1146              if(Packge_information==true)
   1147              {
   1148                  MP_packet_info.err_cnt = 0;
   1149                  MP_packet_info.recv_cnt = 0;
   1150              }
   1151          //#endif
   1152          
   1153              /* dst num must be me */
   1154              if(!num_isequal(&pCmd->dstnbr,  &MP_DevInfo.termNbr))
   1155              {
   1156                  return ;
   1157              }
   1158          
   1159              switch(pCmd->cmdtype)
   1160              {
   1161              case MP_DOWN_ACCEPT:
   1162              {
   1163                  if(Mp_num_isequal(&MP_AudioInfo.peer_termnbr, &pCmd->srcnbr))  /* command from peer */
   1164                  {
   1165                      if(ON_CALLING() || ON_CALLINGWAIT() || ON_FOUND())
   1166                      {
   1167                          MP_StartTalk();
   1168                          Menu_handle_msg(MSG_DIALING_SUCCESS, NULL, 0);
   1169                          MP_ResetAudioStatus(MP_STOP_AUDIO_TIMEOUT);
   1170                          MP_SetPeerNum(&pCmd->srcnbr);
   1171                      }
   1172                      else if(ON_AUDIO())   /* filter redundant*/
   1173                      {
   1174                      }
   1175                      else // I am not calling u
   1176                      {
   1177                          MP_SendCmd(MP_UP_CLOSE, &pCmd->srcnbr, pCmd->seqnum);
   1178                      }
   1179                  }
   1180                  else
   1181                  {
   1182                      MP_SendCmd(MP_UP_CLOSE, &pCmd->srcnbr, pCmd->seqnum);
   1183                  }
   1184                  break;
   1185              }
   1186              case MP_DOWN_FOUND:
   1187              {
   1188                  if(Mp_num_isequal(&MP_AudioInfo.peer_termnbr, &pCmd->srcnbr))  /* command from peer */
   1189                  {
   1190                      if(ON_CALLING() || ON_CALLINGWAIT())   /* found peer successfully */
   1191                      {
   1192                          SET_ON_FOUND();
   1193                          Hal_RingStart(RING_RING, OPENFLAG_ASONCE);
   1194                          MP_SetPeerNum(&pCmd->srcnbr);
   1195                      }
   1196                      else if(ON_FOUND() || ON_AUDIO())       /* filter redundant*/
   1197                      {
   1198                      }
   1199                      else // I am not calling u
   1200                      {
   1201                          MP_SendCmd(MP_UP_CLOSE, &pCmd->srcnbr, pCmd->seqnum);
   1202                      }
   1203                  }
   1204                  else //  another device
   1205                  {
   1206                      MP_SendCmd(MP_UP_CLOSE, &pCmd->srcnbr, pCmd->seqnum);
   1207                  }
   1208          
   1209                  break;
   1210              }
   1211              case MP_DOWN_NOTFOUND:
   1212              {
   1213                  if(Mp_num_isequal(&MP_AudioInfo.peer_termnbr, &pCmd->srcnbr))  /* command from peer */
   1214                  {
   1215                      if(ON_CALLING() || ON_CALLINGWAIT() || ON_FOUND())
   1216                      {
   1217                          if(!Hal_IsVoiceBellPlaying())
   1218                          {
   1219                              Hal_StartVoiceBell(VOICEBELL_OUTOFREACH);
   1220                          }
   1221                      }
   1222                  }
   1223          
   1224                  break;
   1225              }
   1226              case MP_DOWN_BUSY:
   1227              {
   1228                  if(Mp_num_isequal(&MP_AudioInfo.peer_termnbr, &pCmd->srcnbr))  /* command from peer */
   1229                  {
   1230                      if(ON_CALLING() || ON_CALLINGWAIT() || ON_FOUND())
   1231                      {
   1232                          if(!Hal_IsVoiceBellPlaying())
   1233                          {
   1234                              Hal_StartVoiceBell(VOICEBELL_BUSY);
   1235                          }
   1236                      }
   1237                  }
   1238                  break;
   1239              }
   1240              case MP_DOWN_CALL:
   1241              {
   1242                  if(ON_CALLING() || ON_CALLINGWAIT() || ON_FOUND() || ON_CALLED() || ON_AUDIO())
   1243                  {
   1244                      if(Mp_num_isequal(&pCmd->srcnbr, &MP_AudioInfo.peer_termnbr)) //audio started, it is peer downcall retrans
   1245                      {
   1246                          MP_SendCmd(MP_UP_FOUND, &pCmd->srcnbr, pCmd->seqnum);
   1247                          HalResetBackLightEvent();
   1248                      }
   1249                      else     //a new comer and refuse its calling.
   1250                      {
   1251                          MP_SendCmd(MP_UP_BUSY, &pCmd->srcnbr, pCmd->seqnum);
   1252                      }
   1253                  }
   1254                  else if(IS_IDLE() || ON_WAKE())      //Receive CMD_DOWN_CALL in the first time.
   1255                  {
   1256                      MP_SendCmd(MP_UP_FOUND, &pCmd->srcnbr, pCmd->seqnum);
   1257          
   1258                      /* if called, stop sending signals */
   1259                      MP_StopSignalRetrys();
   1260          
   1261                      /* set peer num and cmd seqnum */
   1262                      MP_SetPeerNum(&pCmd->srcnbr);
   1263                      MP_AudioInfo.cmdseqnum = pCmd->seqnum;
   1264          
   1265                      HalResetBackLightEvent();
   1266          
   1267                      Hal_RingStart(RING_ANY, OPENFLAG_ASBELL);
   1268          
   1269                      num_term2str(MP_numstr, &pCmd->srcnbr);
   1270                      Menu_handle_msg(MSG_INCOMING_CALL, MP_numstr, 0);
   1271          
   1272                      SET_ON_CALLED();
   1273          
   1274                      MP_SendCmd(MP_UP_ACCEPT, &MP_AudioInfo.peer_termnbr, MP_AudioInfo.cmdseqnum);
   1275                      MP_AudioInfo.accept_cnt = 0;
   1276                      MP_AudioInfo.retrying_bitmap |= MP_ACCEPT_RETRY_BIT;
   1277                      MP_start_timerEx(MP_TaskId, MP_ACCEPT_RETRY_EVENT, 200);
   1278          
   1279                      MP_StartTalk();
   1280                      MP_ResetAudioStatus(MP_STOP_AUDIO_TIMEOUT);//FIXME:To avoid the other side not start normally.
   1281                  }
   1282                  break;
   1283              }
   1284              case MP_DOWN_CLOSE:
   1285              {
   1286                  if(Mp_num_isequal(&MP_AudioInfo.peer_termnbr, &pCmd->srcnbr))  /* command from peer */
   1287                  {
   1288                      if(ON_CALLED())
   1289                      {
   1290                          Menu_handle_msg(MSG_MISSED_CALL, NULL, 0);
   1291                          Hal_RingStop();
   1292                          MP_ResetAudio();
   1293                          MP_StopSignalRetrys();
   1294                      }
   1295                      else if(ON_AUDIO())
   1296                      {
   1297                          Menu_handle_msg(MSG_VOICE_FINISH, NULL, 0);
   1298                          Hal_RingStop();
   1299                          MP_ResetAudio();
   1300                          MP_StopSignalRetrys();
   1301                      }
   1302                      else if(ON_CALLING() || ON_CALLINGWAIT() || ON_FOUND())
   1303                      {
   1304                          Menu_handle_msg(MSG_INIT_MAIN, NULL, 0);
   1305                          Hal_RingStop();
   1306                          MP_ResetAudio();
   1307                          MP_StopSignalRetrys();
   1308                      }
   1309                  }
   1310                  break;
   1311              }
   1312              }
   1313          
   1314          }
   1315          
   1316          void ReportVehicleCardRssi(void)
   1317          {
   1318              if(u16RssiNum > 0)
   1319              {
   1320                  vehicle_rssi_data.u16seqnum++;
   1321                  MP_SendTunnelToAllCoord((uint8 *)(&vehicle_rssi_data),u16RssiNum*sizeof(vehicle_rssi_ts)+4,42,true);
   1322                  u16RssiNum = 0;
   1323              }
   1324          }
   1325          
   1326          /*void MP_ParseSms(app_mpSMS_t *pSms)
   1327          {
   1328              if(IS_IDLE() || ON_WAKE())   //only receive sms when system is IDLE
   1329              {
   1330                  uint8 idx;
   1331                  sms_saved_t sms;
   1332                  Contact_Node c_node;
   1333                  uint8 rtn;
   1334                  uint8 count;
   1335                  count = Get_SMS_Quantity();
   1336                  if(count < MAX_SMS_NUM)
   1337                  {
   1338                      sms.head.isReaded=false;
   1339                      sms.head.len=pSms->len;
   1340                      sms.head.seqnum=pSms->seqnum;
   1341                      osal_memcpy(&sms.head.nmbr.nbr, &pSms->srcnbr.nbr, APP_NMBRDIGIT);
   1342                      if(ZSuccess == menu_Contact_SearchContactByNum(&c_node, &idx, pSms->srcnbr.nbr))
   1343                      {
   1344                          sms.head.Contect_item_L= *((uint8*)contact_item_L+idx);
   1345                      }
   1346                      else
   1347                      {
   1348                          sms.head.Contect_item_L=LIST_ITEM_NULL;
   1349                      }
   1350                      strncpy((char*)sms.content,(char *)pSms+sizeof(app_mpSMS_t),pSms->len);
   1351                      // strncpy((char*)sms.content,(char *)pSms->len+sizeof(uint_8),pSms->len);
   1352          
   1353                      if(menu_SMS_Search_Inbox(pSms)==ZFailure)
   1354                      {
   1355                          rtn =menu_SMS_Add(&sms,SMSTYPE_INBOX); //Save_New_SMS(pSms);
   1356                          if(rtn == ZSUCCESS)
   1357                          {
   1358                              Menu_Set_SMS_Full_Ring_Flag(TRUE);
   1359                              Hal_RingStart(RING_ANY, OPENFLAG_ASSMS_POW);
   1360                              HalResetBackLightEvent();
   1361                              Menu_handle_msg(MSG_SMS_INCOMING, NULL, 0);
   1362                          }
   1363                      }
   1364          
   1365                      app_mpSMS_t app_mpSMS;
   1366                      app_mpSMS.srcnbr = pSms->srcnbr;
   1367                      app_mpSMS.dstnbr = pSms->dstnbr;
   1368                      app_mpSMS.smstype = APP_MP_SMSTYPE_ACK;
   1369                      app_mpSMS.seqnum = pSms->seqnum;
   1370                      app_mpSMS.len = 0;
   1371                      rtn =MP_SendSignalToCoord((uint8 *)&app_mpSMS, sizeof(app_mpSMS), MP_SMS, true);
   1372                      return;
   1373                  }
   1374                  else
   1375                  {
   1376                      if(Menu_Get_SMS_Full_Ring_Flag())
   1377                      {
   1378                          Menu_Set_SMS_Full_Ring_Flag(FALSE);
   1379                          Hal_RingStart(RING_ANY, OPENFLAG_ASSMS_POW);
   1380                          HalResetBackLightEvent();
   1381                      }
   1382                      Menu_handle_msg(MSG_SMS_INCOMING, NULL, 0);
   1383                  }
   1384              }
   1385          
   1386          }*/
   1387          
   1388          void MP_ParseJoin(app_mpJoinNwk_t *p, uint16 panid, int8 rssi)
   1389          {
   1390              if(MP_NwkInfo.nwkState == NWK_DETAIL_JOINASSOCING || MP_NwkInfo.nwkState == NWK_DETAIL_CELLSWITCHING
   1391                      || MP_NwkInfo.nwkState == NWK_DETAIL_INIT)
   1392              {
   1393                  if(p->joinnwktype == APP_MP_JOINNWK_SUCCESS)
   1394                  {
   1395                      //first time or being lost doesn't need send leave
   1396                      if(MP_DevInfo.CoordPanID != 0xFFFF
   1397                              && panid != MP_DevInfo.CoordPanID)
   1398                      {
   1399                          app_mpLeaveNwk_t app_mpLeaveNwk;
   1400                          app_mpLeaveNwk.hdr.srcaddr = MP_DevInfo.nmbr;
   1401                          app_mpLeaveNwk.hdr.dstaddr = APP_ARMSHORTADDR;
   1402                          app_mpLeaveNwk.seqnum = MP_seqnums.join_seqnum;  // in cellswitch, the seqnum is the same as join
   1403                          MP_SendSignalToCoord((uint8 *)&app_mpLeaveNwk, sizeof(app_mpLeaveNwk), MP_LEAVE_NOTIFY, true);
   1404                      }
   1405          
   1406                      MP_DevInfo.armid = p->armid;
   1407                      MP_DevInfo.CoordPanID = panid;
   1408                      MP_NwkInfo.nwkState = NWK_DETAIL_ENDDEVICE;
   1409                      MP_DevInfo.currentRssi = rssi;
   1410                      MP_DevInfo.hascoordlink = true;
   1411          
   1412                      //updata time
   1413                      timeSyncCnt = 0;
   1414          
   1415                      /* stop other cell switchs */
   1416                      osal_stop_timerEx(MP_Function_TaskID, MP_FUNC_JOIN_SWITCH_EVENT);
   1417                      osal_clear_event(MP_Function_TaskID, MP_FUNC_JOIN_SWITCH_EVENT);
   1418                      MP_ClearCellInfo();
   1419          
   1420                      /*stop join timeout alarm*/
   1421                      HAL_AlarmUnSet(MP_ALARM_JOIN);
   1422          
   1423                      /* jump menu when searching nwk */
   1424                      Menu_RefreshNwkDisp();
   1425          
   1426                      /* start a poll immederately*/
   1427                      MP_start_timerEx(MP_Function_TaskID, MP_FUNC_POLL_EVENT, 5);
   1428          
   1429                      if(Hal_AllowSleep() && MP_AudioInfo.retrying_bitmap == 0)
   1430                      {
   1431                          osal_start_timerEx(MP_Function_TaskID, MP_FUNC_PERIODIC_SLEEP_EVENT, 150);
   1432                      }
   1433                      /* start probe network */
   1434                      MP_start_timerEx(MP_TaskId, MP_PROBENWK_EVENT, MP_NWKTOLERANCE_TIME * 1000);
   1435          
   1436                  }
   1437                  else if(p->joinnwktype == APP_MP_JOINNWK_DENIED)     //terminate cell swith, all things maintained
   1438                  {
   1439                      //try next immediately
   1440                      osal_stop_timerEx(MP_Function_TaskID, MP_FUNC_JOIN_SWITCH_EVENT);
   1441                      MP_set_event(MP_Function_TaskID, MP_FUNC_JOIN_SWITCH_EVENT);
   1442                  }
   1443              }
   1444          }
   1445          void MP_ParseTime(app_mpTime_t *p)
   1446          {
   1447              Date_t date;
   1448              Time_t time;
   1449              time.hour = p->hour;
   1450              time.min = p->minute;
   1451              time.sec = p->second;
   1452              SetTime(time);
   1453          
   1454              date.year = p->year;
   1455              date.mon = p->month;
   1456              date.day = p->day;
   1457              SetDate(date);
   1458              Menu_UpdateTime();
   1459          }
   1460          void MP_ParsePoll(app_mpPoll_t *p, int8 rssi)
   1461          {
   1462              MP_DevInfo.currentRssi = rssi;
   1463              MP_DevInfo.hascoordlink = true;
   1464              switch(p->flag)
   1465              {
   1466              case APP_MPPOLL_FLAG_NONE:
   1467              {
   1468                  /* if hal allowed, go to sleep at once, else idle until WORK INTERVAL ends*/
   1469                  if(Hal_AllowSleep())
   1470                  {
   1471                      MP_start_timerEx(MP_Function_TaskID,MP_FUNC_PERIODIC_SLEEP_EVENT,15);
   1472                  }
   1473                  break;
   1474              }
   1475              case APP_MPPOLL_FLAG_START:
   1476              {
   1477                  Menu_handle_msg(MSG_POLL_START, NULL, 0);
   1478                  break;
   1479              }
   1480              case APP_MPPOLL_FLAG_END:
   1481              {
   1482                  Menu_handle_msg(MSG_POLL_END, NULL, 0);
   1483                  break;
   1484              }
   1485              case APP_MPPOLL_FLAG_REJOIN:
   1486              {
   1487                  /* set nwk false, and join automately*/
   1488                  MP_NwkInfo.nwkState = NWK_DETAIL_INIT;
   1489                  MP_DevInfo.CoordPanID = 0xFFFF;
   1490                  MP_DevInfo.armid = APP_INVALIDARMADDR;
   1491                  MP_DevInfo.currentRssi = MP_MIN_RSSI;
   1492                  Menu_RefreshNwkDisp();
   1493                  break;
   1494              }
   1495              }
   1496          
   1497          
   1498              uint8 signalLevel = MP_Rssi2Level(rssi);
   1499              Menu_UpdateSignal(signalLevel);
   1500          //#ifdef  RSSI_INFORMATION
   1501              if(Rssi_information==true)
   1502              {
   1503                  Menu_UpdateRSSI(rssi);
   1504                  Menu_UpdateLinkFlag(true);
   1505              }
   1506          //#endif
   1507              MP_RejoinTimes = 0;
   1508              osal_start_timerEx(MP_TaskId, MP_PROBENWK_EVENT, MP_NWKTOLERANCE_TIME * 1000);
   1509          
   1510          }
   1511          /*********************************************************************
   1512          * @fn
   1513          * @brief
   1514          * @return
   1515          *********************************************************************/
   1516          static  uint8  MP_ReadExtAddr(void)
   1517          {
   1518              //osal_nv_item_init( ZCD_NV_EXTADDR, Z_EXTADDR_LEN, NULL );
   1519              //osal_nv_read( ZCD_NV_EXTADDR, 0, Z_EXTADDR_LEN, &MP_DevInfo.ExitAddr);
   1520          
   1521              HalFlashRead(HAL_FLASH_IEEE_PAGE, HAL_FLASH_IEEE_OSET, (uint8 *)&MP_DevInfo.ExitAddr, HAL_FLASH_IEEE_SIZE);
   1522          
   1523              /* Channel */
   1524              uint8 channel = MP_DevInfo.ExitAddr[EXT_MACADDR_CHANNEL];
   1525          
   1526              if(!(channel>=11 && channel <=26))
   1527              {
   1528                  channel = 14;   //use default channel 14;
   1529              }
   1530          
   1531              uint16 number,number0,number1,number2,number3;
   1532          
   1533              number0=(MP_DevInfo.ExitAddr[EXT_MACADDR_DEVID_LBYTE]&0x0F);
   1534              number1=((MP_DevInfo.ExitAddr[EXT_MACADDR_DEVID_LBYTE]>>4)&0x0F);
   1535              number2=(MP_DevInfo.ExitAddr[EXT_MACADDR_DEVID_HBYTE]&0x0F);
   1536              number3=((MP_DevInfo.ExitAddr[EXT_MACADDR_DEVID_HBYTE]>>4)&0x0F);
   1537          
   1538              number = number0+10*number1+100*number2+1000*number3;
   1539          
   1540              if((number0>9)||(number1>9)||(number2>9)||(number3>9)
   1541                      ||!NUMBER_IS_PHONE(number))
   1542              {
   1543                  HAL_ASSERT(false);
   1544              }
   1545              MP_DevInfo.nmbr = number;
   1546          
   1547          //#ifdef MENU_RF_DEBUG
   1548              if(Menu_rf_debug==TRUE)
   1549              {
   1550                  uint8 rs = osal_nv_item_init(ZCD_NV_SET_CHANLIST, sizeof(uint8), NULL);
   1551                  if(rs == ZSUCCESS)
   1552                  {
   1553                      if(ZSuccess != osal_nv_read(ZCD_NV_SET_CHANLIST, 0, sizeof(uint8), &MP_DevInfo.Channel))
   1554                      {
   1555                          MP_DevInfo.Channel = channel;
   1556                      }
   1557          
   1558                      if(MP_DevInfo.Channel > 0x1A || MP_DevInfo.Channel < 0x0B)
   1559                      {
   1560                          MP_DevInfo.Channel = MP_DevInfo.ExitAddr[EXT_MACADDR_CHANNEL];
   1561                      }
   1562          
   1563                  }
   1564                  else
   1565                  {
   1566                      MP_DevInfo.Channel = channel;
   1567                      if(rs == NV_ITEM_UNINIT)
   1568                      {
   1569                          osal_nv_write(ZCD_NV_SET_CHANLIST, 0, sizeof(uint8), &MP_DevInfo.Channel);
   1570                      }
   1571                  }
   1572          
   1573                  rs = osal_nv_item_init(ZCD_NV_SET_PANID, sizeof(uint16), NULL);
   1574                  if(rs == ZSUCCESS)
   1575                  {
   1576                      if(ZSuccess != osal_nv_read(ZCD_NV_SET_PANID, 0, sizeof(uint16), &MP_DevInfo.DesireCoordPanID))
   1577                      {
   1578                          MP_DevInfo.DesireCoordPanID = 0xFFFF;
   1579                      }
   1580                  }
   1581                  else
   1582                  {
   1583                      MP_DevInfo.DesireCoordPanID = 0xFFFF;
   1584                      if(rs== NV_ITEM_UNINIT)
   1585                      {
   1586                          osal_nv_write(ZCD_NV_SET_PANID, 0, sizeof(uint16), &MP_DevInfo.DesireCoordPanID);
   1587                      }
   1588                  }
   1589                  /* phone Nmbr */
   1590                  MP_NumberInfo_t numberInfo;
   1591                  rs = osal_nv_item_init(ZCD_NV_SET_PHONENUM, sizeof(MP_NumberInfo_t), NULL);
   1592                  if(rs == NV_ITEM_UNINIT)
   1593                  {
   1594                      numberInfo.setted = FALSE;  // default unseted
   1595                      numberInfo.phone_number = 0xFFFF;
   1596                      numberInfo.checkxor = HI_UINT16(numberInfo.phone_number)  ^ LO_UINT16(numberInfo.phone_number);
   1597                      osal_nv_write(ZCD_NV_SET_PHONENUM,0, sizeof(numberInfo), &numberInfo);
   1598                  }
   1599          
   1600                  rs = osal_nv_read(ZCD_NV_SET_PHONENUM,0, sizeof(MP_NumberInfo_t), &numberInfo);
   1601          
   1602                  if(rs == ZSUCCESS
   1603                          && numberInfo.setted==TRUE
   1604                          && NUMBER_IS_PHONE(numberInfo.phone_number)
   1605                          && numberInfo.checkxor == HI_UINT16(numberInfo.phone_number)  ^ LO_UINT16(numberInfo.phone_number))  // if setted in flash
   1606                  {
   1607                      MP_DevInfo.nmbr = numberInfo.phone_number;
   1608                  }
   1609              }
   1610              else
   1611              {
   1612                  MP_DevInfo.Channel = channel;
   1613                  MP_DevInfo.DesireCoordPanID = 0xFFFF;
   1614              }
   1615          
   1616              _itoa(MP_DevInfo.nmbr, MP_numstr, 10);
   1617              num_str2term(&MP_DevInfo.termNbr, MP_numstr);
   1618              return 0;
   1619          }
   1620          
   1621          
   1622          void MP_ResetFrameblk(void)
   1623          {
   1624              MP_AudioInfo.seqnum = 0;
   1625          }
   1626          
   1627          void MP_ResetAudioStatus(uint16 timeout)
   1628          {
   1629              osal_stop_timerEx(MP_TaskId, MP_STOP_AUDIO_EVENT);
   1630              osal_clear_event(MP_TaskId, MP_STOP_AUDIO_EVENT);
   1631              if(ZSUCCESS!=osal_start_timerEx(MP_TaskId, MP_STOP_AUDIO_EVENT, timeout))
   1632              {
   1633                  SystemReset();
   1634              }
   1635              /* if I did not receive audio in 5 seconds, may be last station is losted, start a scan immediately */
   1636              /*if(ZSUCCESS!=osal_start_timerEx(MP_TaskId, MP_SCAN_AUDIO_EVENT, timeout/2))
   1637              {
   1638                  SystemReset();
   1639              }*/
   1640          }
   1641          
   1642          bool MP_CellSwitchCondition(uint16 panid, int8 rssi)
   1643          {
   1644              /* save the coord rssi */
   1645              if(MP_IsNwkOn() && panid == MP_DevInfo.CoordPanID)
   1646              {
   1647                  MP_DevInfo.currentRssi = rssi ;
   1648                  MP_DevInfo.hascoordlink = true;
   1649                  return true;
   1650              }
   1651          
   1652              if(rssi <  MP_DevInfo.currentRssi + MP_CELL_DIFFRSSI)
   1653              {
   1654                  return false;
   1655              }
   1656          
   1657              /* find idx */
   1658              int8 idx;
   1659              if((idx = MP_SearchCellInfo(panid, rssi)) >= 0)
   1660              {
   1661                  MP_CellInfo.CellInfo[idx].matched = true;
   1662                  MP_CellInfo.CellInfo[idx].cnt++;
   1663                  MP_CellInfo.CellInfo[idx].rssi = rssi;
   1664                  MP_CellInfo.CellInfo[idx].panid = panid;
   1665              }
   1666          
   1667              return true;
   1668          }
   1669          
   1670          int8  MP_SearchCellInfo(uint16 panid , int8 rssi)
   1671          {
   1672              /* find if already have */
   1673              for(uint8 i = 0; i < MP_MAC_MAXSCAN_RESULTS; i++)
   1674              {
   1675          
   1676                  if(MP_CellInfo.CellInfo[i].panid == panid)
   1677                  {
   1678                      return (int8)i;
   1679                  }
   1680              }
   1681          
   1682              /* find an empty */
   1683              for(uint8 i = 0; i < MP_MAC_MAXSCAN_RESULTS; i++)
   1684              {
   1685                  if(MP_CellInfo.CellInfo[i].cnt == 0)
   1686                  {
   1687                      return (int8)i;
   1688                  }
   1689              }
   1690          
   1691              MP_SortCellInfo();
   1692          
   1693              if(rssi>MP_CellInfo.CellInfo[MP_MAC_MAXSCAN_RESULTS-1].rssi)
   1694              {
   1695                  return (int8)(MP_MAC_MAXSCAN_RESULTS-1);
   1696              }
   1697          
   1698              return -1;
   1699          }
   1700          
   1701          bool  MP_SilenceSignCheck(uint16 sign, uint8 datasize)
   1702          {
   1703              uint8 validbits = 0;
   1704              for(uint8 i = 0; i < VOICE_IDX_THRESHOLD; i++)
   1705              {
   1706                  if(sign >> i & 0x01)
   1707                  {
   1708                      validbits++;
   1709                  }
   1710              }
   1711              return (datasize == VOICE_PER_RAW_DATA_LEN * validbits) ? true : false;
   1712          }
   1713          
   1714          #ifdef CFG_STATION_CHECK
   1715          void MP_Station_Signal_Update(void)
   1716          {
   1717              static uint8 channel_list[6] = {0x19,0x18,0x17,0x16,0x15,0x0E};
   1718          
   1719              static uint8 cnt;
   1720              if(CurrentNodeID == MENU_ID_SETTINGS_STATION_CHECK)
   1721              {
   1722          
   1723                  MAC_MlmeSetReq(MAC_PROMISCUOUS_MODE, &MP_MACTrue);
   1724                  //macRxPromiscuousMode(MAC_PROMISCUOUS_MODE_COMPLIANT);
   1725                  FRMFILT0 &= ~(0x01);
   1726                  macChipVersion = REV_A;//CHVER;
   1727          
   1728                  MAC_MlmeSetReq(MAC_LOGICAL_CHANNEL, &channel_list[cnt]);
   1729                  cnt = (++cnt)%6;
   1730          
   1731                  menu_display();
   1732                  if(SUCCESS!=osal_start_timerEx(MP_TaskId, MP_STATION_CHECK_EVENT, 1000))
   1733                  {
   1734                      SystemReset();
   1735                  }
   1736              }
   1737          }
   1738          #endif
   1739          

   Maximum stack usage in bytes:

     Function                     ISTACK PSTACK XSTACK
     --------                     ------ ------ ------
     MAC_CbackCheckPending            0      0      0
     MAC_CbackEvent                   2      0     16
       -> osal_msg_allocate           0      0     28
       -> osal_memcpy                 0      0     32
       -> osal_memcpy                 0      0     32
       -> osal_memcpy                 0      0     32
       -> osal_msg_allocate           0      0     28
       -> osal_memcpy                 0      0     32
       -> osal_msg_send               0      0     28
     MP_CellSwitchCondition           1      0     25
       -> MP_IsNwkOn                  0      0     18
       -> MP_SearchCellInfo           0      0     18
     MP_DeviceStartup                 3      0     22
       -> MAC_MlmeSetReq              4      0     26
       -> MAC_MlmeSetReq              4      0     26
       -> MAC_MlmeSetReq              4      0     26
       -> MAC_MlmeSetReq              4      0     26
       -> MAC_MlmeSetReq              4      0     26
       -> MAC_MlmeSetReq              4      0     26
       -> MAC_MlmeSetReq              4      0     26
       -> MAC_MlmeSetReq              4      0     26
       -> MAC_MlmeSetReq              4      0     26
       -> MAC_MlmeSetReq              4      0     26
       -> MAC_MlmeSetReq              4      0     26
       -> MAC_MlmeSetReq              4      0     26
       -> MAC_MlmeSetReq              4      0     26
     MP_Init                          0      0      9
       -> Menu_handle_msg             0      0     18
       -> MAC_Init                    0      0     18
       -> MAC_InitDevice              0      0     18
       -> MAC_MlmeResetReq            0      0     18
       -> MP_ReadR_or_DInfo           0      0     18
       -> MP_ReadExtAddr              0      0     18
       -> MP_DeviceStartup            0      0     18
       -> MP_set_event                0      0     18
       -> HalAudioInit                0      0     18
       -> init_uart                   0      0     18
       -> MP_start_timerEx            0      0     18
     MP_ParseAppFrame                 0      0     33
       -> MP_ParseVoice               0      0     32
       -> MP_ParseCmd                 0      0     32
       -> MP_CellSwitchCondition      0      0     32
       -> MP_ParseJoin                0      0     32
       -> GetDate                     0      0     32
       -> MP_ParseTime                0      0     32
       -> MP_ParsePoll                0      0     32
     MP_ParseCmd                      0      0     26
       -> num_isequal                 0      0     20
       -> Mp_num_isequal              0      0     20
       -> MP_JudgeStatus              0      0     20
       -> MP_JudgeStatus              0      0     20
       -> MP_JudgeStatus              0      0     20
       -> MP_StartTalk                0      0     20
       -> Menu_handle_msg             0      0     20
       -> MP_ResetAudioStatus         0      0     20
       -> MP_SetPeerNum               0      0     20
       -> MP_JudgeStatus              0      0     20
       -> MP_SendCmd                  0      0     20
       -> Mp_num_isequal              0      0     20
       -> MP_JudgeStatus              0      0     20
       -> MP_JudgeStatus              0      0     20
       -> MP_SetStatus                0      0     20
       -> Hal_RingStart               0      0     20
       -> MP_SetPeerNum               0      0     20
       -> MP_JudgeStatus              0      0     20
       -> MP_JudgeStatus              0      0     20
       -> Mp_num_isequal              0      0     20
       -> MP_JudgeStatus              0      0     20
       -> MP_JudgeStatus              0      0     20
       -> MP_JudgeStatus              0      0     20
       -> Hal_IsVoiceBellPlaying      0      0     20
       -> Hal_StartVoiceBell          0      0     20
       -> Mp_num_isequal              0      0     20
       -> MP_JudgeStatus              0      0     20
       -> MP_JudgeStatus              0      0     20
       -> MP_JudgeStatus              0      0     20
       -> Hal_IsVoiceBellPlaying      0      0     20
       -> Hal_StartVoiceBell          0      0     20
       -> MP_JudgeStatus              0      0     20
       -> MP_JudgeStatus              0      0     20
       -> MP_JudgeStatus              0      0     20
       -> MP_JudgeStatus              0      0     20
       -> MP_JudgeStatus              0      0     20
       -> Mp_num_isequal              0      0     20
       -> MP_SendCmd                  0      0     20
       -> HalResetBackLightEvent      0      0     20
       -> MP_SendCmd                  0      0     20
       -> MP_JudgeStatus              0      0     20
       -> MP_JudgeStatus              0      0     20
       -> MP_SendCmd                  0      0     20
       -> MP_StopSignalRetrys         0      0     20
       -> MP_SetPeerNum               0      0     20
       -> HalResetBackLightEvent      0      0     20
       -> Hal_RingStart               0      0     20
       -> num_term2str                0      0     20
       -> Menu_handle_msg             0      0     20
       -> MP_SetStatus                0      0     20
       -> MP_SendCmd                  0      0     20
       -> MP_start_timerEx            0      0     20
       -> MP_StartTalk                0      0     20
       -> MP_ResetAudioStatus         0      0     20
       -> Mp_num_isequal              0      0     20
       -> MP_JudgeStatus              0      0     20
       -> Menu_handle_msg             0      0     20
       -> Hal_RingStop                0      0     20
       -> MP_ResetAudio               0      0     20
       -> MP_StopSignalRetrys         0      0     20
       -> MP_JudgeStatus              0      0     20
       -> Menu_handle_msg             0      0     20
       -> Hal_RingStop                0      0     20
       -> MP_ResetAudio               0      0     20
       -> MP_StopSignalRetrys         0      0     20
       -> MP_JudgeStatus              0      0     20
       -> MP_JudgeStatus              0      0     20
       -> MP_JudgeStatus              0      0     20
       -> Menu_handle_msg             0      0     20
       -> Hal_RingStop                0      0     20
       -> MP_ResetAudio               0      0     20
       -> MP_StopSignalRetrys         0      0     20
     MP_ParseJoin                     0      0     35
       -> MP_SendSignalToCoord        0      0     38
       -> osal_stop_timerEx           0      0     38
       -> osal_clear_event            0      0     38
       -> MP_ClearCellInfo            0      0     38
       -> HAL_AlarmUnSet              0      0     38
       -> Menu_RefreshNwkDisp         0      0     38
       -> MP_start_timerEx            0      0     38
       -> Hal_AllowSleep              0      0     38
       -> osal_start_timerEx          0      0     38
       -> MP_start_timerEx            0      0     38
       -> osal_stop_timerEx           0      0     38
       -> MP_set_event                0      0     38
     MP_ParsePoll                     0      0     25
       -> Hal_AllowSleep              0      0     18
       -> MP_start_timerEx            0      0     18
       -> Menu_handle_msg             0      0     18
       -> Menu_handle_msg             0      0     18
       -> Menu_RefreshNwkDisp         0      0     18
       -> MP_Rssi2Level               0      0     18
       -> Menu_UpdateSignal           0      0     18
       -> Menu_UpdateRSSI             0      0     18
       -> Menu_UpdateLinkFlag         0      0     18
       -> osal_start_timerEx          0      0     18
     MP_ParseTime                     0      0     43
       -> SetTime                     0      0     54
       -> SetDate                     0      0     54
       -> Menu_UpdateTime             0      0     42
     MP_ParseVoice                    1      0     64
       -> osal_GetSystemClock         0      0     92
       -> MP_SilenceSignCheck         0      0     92
       -> _itoa                       0      0     92
       -> num_str2term                0      0     92
       -> MP_SetPeerNum               0      0     92
       -> Menu_RefreshNwkDisp         0      0     92
       -> memcpy                      0      0     96
       -> memcpy                      0      0     96
       -> FillAudioBuffer             0      0     92
       -> osal_start_timerEx          0      0     92
       -> MP_JudgeStatus              0      0     92
       -> MP_JudgeStatus              0      0     92
       -> MP_SendCmd                  0      0     92
       -> MP_JudgeStatus              0      0     92
       -> MP_JudgeStatus              0      0     92
       -> MP_JudgeStatus              0      0     92
       -> MP_StartTalk                0      0     92
       -> Menu_handle_msg             0      0     92
       -> MP_Rssi2Level               0      0     92
       -> Menu_UpdateSignal           0      0     92
       -> MP_ResetAudioStatus         0      0     92
     MP_ProcessEvent                  1      0     17
       -> osal_start_timerEx          0      0     28
       -> SystemReset                 0      0     28
       -> mac_msg_deallocate          0      0     28
       -> MP_ParseAppFrame            0      0     34
       -> mac_msg_deallocate          0      0     28
       -> osal_msg_receive            0      0     28
       -> MP_JudgeStatus              0      0     28
       -> MP_JudgeStatus              0      0     28
       -> MP_SendCmd                  0      0     28
       -> MP_start_timerEx            0      0     28
       -> MP_SendCmd                  0      0     28
       -> MP_start_timerEx            0      0     28
       -> MP_SendCmd                  0      0     28
       -> MP_start_timerEx            0      0     28
       -> MP_JudgeStatus              0      0     28
       -> HalAudioClose               0      0     28
       -> Menu_handle_msg             0      0     28
       -> HAL_AlarmSet                0      0     28
       -> Menu_RefreshNwkDisp         0      0     28
       -> Menu_UpdateSignal           0      0     28
       -> MP_start_timerEx            0      0     28
       -> AudioIsEnabled              0      0     28
       -> SystemReset                 0      0     28
       -> MP_JudgeStatus              0      0     28
       -> MP_start_timerEx            0      0     28
       -> HalUARTRead                 0      0     28
       -> MP_JudgeStatus              0      0     28
       -> MP_JudgeStatus              0      0     28
       -> AudioIsEnabled              0      0     28
       -> MP_ResetAudioStatus         0      0     28
       -> MP_ResetAudio               0      0     28
       -> MP_StopSignalRetrys         0      0     28
       -> Hal_StartVoiceBell          0      0     28
       -> AudioIsEnabled              0      0     28
       -> MP_ResetAudioStatus         0      0     28
       -> MP_ResetAudio               0      0     28
       -> MP_StopSignalRetrys         0      0     28
       -> Hal_StartVoiceBell          0      0     28
       -> AudioIsEnabled              0      0     28
       -> MP_ResetAudioStatus         0      0     28
       -> MP_ResetAudio               0      0     28
       -> MP_StopSignalRetrys         0      0     28
       -> Hal_StartVoiceBell          0      0     28
       -> MP_ResetAudioStatus         0      0     28
       -> MP_ResetAudio               0      0     28
       -> MP_StopSignalRetrys         0      0     28
       -> Hal_StartVoiceBell          0      0     28
       -> AudioIsEnabled              0      0     28
       -> MP_ResetAudioStatus         0      0     28
       -> MP_ResetAudio               0      0     28
       -> MP_StopSignalRetrys         0      0     28
       -> Hal_StartVoiceBell          0      0     28
       -> AudioIsEnabled              0      0     28
       -> MP_ResetAudioStatus         0      0     28
       -> MP_ResetAudio               0      0     28
       -> MP_StopSignalRetrys         0      0     28
       -> Hal_StartVoiceBell          0      0     28
       -> AudioIsEnabled              0      0     28
       -> MP_ResetAudioStatus         0      0     28
       -> MP_ResetAudio               0      0     28
       -> MP_StopSignalRetrys         0      0     28
       -> Hal_StartVoiceBell          0      0     28
       -> ReportVehicleCardRssi       0      0     28
       -> MP_start_timerEx            0      0     28
     MP_ReadExtAddr                   1      0     31
       -> HalFlashRead                0      0     40
       -> halAssertHandler            0      0     36
       -> osal_nv_item_init           0      0     40
       -> osal_nv_read                0      0     44
       -> osal_nv_write               0      0     44
       -> osal_nv_item_init           0      0     40
       -> osal_nv_read                0      0     44
       -> osal_nv_write               0      0     44
       -> osal_nv_item_init           0      0     40
       -> osal_nv_write               0      0     44
       -> osal_nv_read                0      0     44
       -> _itoa                       0      0     36
       -> num_str2term                0      0     36
     MP_ReadR_or_DInfo                1      0     25
       -> osal_nv_item_init           0      0     28
       -> osal_nv_write               0      0     32
       -> osal_nv_read                0      0     32
     MP_ResetAudioStatus              0      0     55
       -> osal_stop_timerEx           0      0     18
       -> osal_clear_event            0      0     18
       -> osal_start_timerEx          0      0     18
       -> SystemReset                 0      0     18
     MP_ResetFrameblk                 2      0      0
     MP_SearchCellInfo                0      0     18
       -> MP_SortCellInfo             0      0     18
     MP_SetR_or_DInfo                 1      0     15
       -> osal_nv_read                0      0     30
       -> osal_nv_write               0      0     30
     MP_SilenceSignCheck              0      0     56
     MP_to_release_vesion             1      0     15
       -> osal_nv_write               0      0     30
     Mp_num_isequal                   0      0     24
     ReportVehicleCardRssi            2      0     14
       -> MP_SendTunnelToAllCoord     4      0      0
     SysUtil_vConvertEndian           1      0     12
     init_uart                        1      0     47
       -> HalUARTOpen                 0      0     76


   Segment part sizes:

     Function/Label                         Bytes
     --------------                         -----
     WDCTL                                     1
     Menu_rf_debug                             1
     Rssi_information                          1
     Packge_information                        1
     uartReadBuf                             128
     uartlen                                   1
     uart_recv_state                           1
     card_status                               1
     MP_cbackSizeTable                        16
     MP_MACTrue                                1
     MP_MACFalse                               1
     MP_TaskId                                 1
     MP_RFState                                1
     MP_packet_info                            6
     MP_RejoinTimes                            1
     signal_update_count                       1
     MP_numstr                                21
     MP_VoiceBuf                              72
     vehicle_rssi_data                        64
     u16RssiNum                                2
     seqnumerrcnt                              2
     MP_Init                                 169
     ??Subroutine7_0                           5
     Mp_num_isequal                          196
     ?Subroutine1                              5
     MP_to_release_vesion                     73
     ?Subroutine2                              2
     ??Subroutine5_0                           3
     ??Subroutine6_0                           5
     MP_ReadR_or_DInfo                       170
     MP_SetR_or_DInfo                        110
     MP_ProcessEvent                        1165
     ?Subroutine3                              5
     init_uart                               107
     ?Subroutine0                              3
     MAC_CbackEvent                          372
     MAC_CbackCheckPending                     5
     MP_DeviceStartup                        239
     ?Subroutine4                              7
     SysUtil_vConvertEndian                   97
     MP_ParseAppFrame                        352
     MP_ParseVoice                           694
     src_change_cnt                            1
     MP_ParseCmd                             751
     ReportVehicleCardRssi                    58
     MP_ParseJoin                            346
     MP_ParseTime                            201
     MP_ParsePoll                            165
     MP_ReadExtAddr                          784
     MP_ResetFrameblk                         12
     MP_ResetAudioStatus                      58
     MP_CellSwitchCondition                  179
     MP_SearchCellInfo                       100
     MP_SilenceSignCheck                      59
     ?<Initializer for MP_MACTrue>             1
     ?<Initializer for signal_update_count>    1
     ??MP_Init?relay                           6
     ??Mp_num_isequal?relay                    6
     ??MP_to_release_vesion?relay              6
     ??MP_ReadR_or_DInfo?relay                 6
     ??MP_SetR_or_DInfo?relay                  6
     ??MP_ProcessEvent?relay                   6
     ??init_uart?relay                         6
     ??MAC_CbackEvent?relay                    6
     ??MAC_CbackCheckPending?relay             6
     ??MP_DeviceStartup?relay                  6
     ??SysUtil_vConvertEndian?relay            6
     ??MP_ParseAppFrame?relay                  6
     ??MP_ParseVoice?relay                     6
     ??MP_ParseCmd?relay                       6
     ??ReportVehicleCardRssi?relay             6
     ??MP_ParseJoin?relay                      6
     ??MP_ParseTime?relay                      6
     ??MP_ParsePoll?relay                      6
     ??MP_ReadExtAddr?relay                    6
     ??MP_ResetFrameblk?relay                  6
     ??MP_ResetAudioStatus?relay               6
     ??MP_CellSwitchCondition?relay            6
     ??MP_SearchCellInfo?relay                 6
     ??MP_SilenceSignCheck?relay               6

 
 6 497 bytes in segment BANKED_CODE
   144 bytes in segment BANK_RELAYS
    16 bytes in segment CODE_C
     1 byte  in segment SFR_AN
     2 bytes in segment XDATA_I
     2 bytes in segment XDATA_ID
   306 bytes in segment XDATA_Z
 
 6 659 bytes of CODE  memory
     0 bytes of DATA  memory (+ 1 byte shared)
   308 bytes of XDATA memory

Errors: none
Warnings: 2
